{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AymaraLang \u2014 Documentaci\u00f3n oficial \u00b6 Bienvenido a la documentaci\u00f3n oficial de AymaraLang ( aym ), un lenguaje de programaci\u00f3n inspirado en la lengua aymara y con un compilador escrito en C++17. Aqu\u00ed encontrar\u00e1s desde una introducci\u00f3n general hasta una referencia completa del lenguaje, la arquitectura del compilador y las gu\u00edas de instalaci\u00f3n. \u00bfPor d\u00f3nde empezar? \u00b6 Primera vez: lee la Visi\u00f3n general y el apartado de Primeros pasos . Aprendizaje pr\u00e1ctico: consulta la Gu\u00eda de caracter\u00edsticas . Referencia completa: revisa la Referencia del lenguaje y la Gram\u00e1tica formal . Desarrollo del compilador: visita Arquitectura y CLI y flujo de compilaci\u00f3n . Estructura de la documentaci\u00f3n \u00b6 Visi\u00f3n general : identidad, objetivos y conceptos clave. Lenguaje : sintaxis base, ejemplos y gu\u00eda de caracter\u00edsticas. Referencia : operadores, funciones integradas, palabras clave y gram\u00e1tica. Compilador : arquitectura y flujo de compilaci\u00f3n. Construcci\u00f3n e instalaci\u00f3n : pasos por plataforma y generaci\u00f3n de instaladores. Proyecto : estructura del repo, contribuciones y roadmap. Sistemas de ingenier\u00eda : documentos de arquitectura, requisitos y validaci\u00f3n. Recursos : presentaciones y material complementario. Construir la documentaci\u00f3n con MkDocs \u00b6 La documentaci\u00f3n est\u00e1 preparada para MkDocs . pip install mkdocs mkdocs serve Luego abre http://127.0.0.1:8000 en tu navegador. Siguiente: Visi\u00f3n general","title":"Inicio"},{"location":"#aymaralang-documentacion-oficial","text":"Bienvenido a la documentaci\u00f3n oficial de AymaraLang ( aym ), un lenguaje de programaci\u00f3n inspirado en la lengua aymara y con un compilador escrito en C++17. Aqu\u00ed encontrar\u00e1s desde una introducci\u00f3n general hasta una referencia completa del lenguaje, la arquitectura del compilador y las gu\u00edas de instalaci\u00f3n.","title":"AymaraLang \u2014 Documentaci\u00f3n oficial"},{"location":"#por-donde-empezar","text":"Primera vez: lee la Visi\u00f3n general y el apartado de Primeros pasos . Aprendizaje pr\u00e1ctico: consulta la Gu\u00eda de caracter\u00edsticas . Referencia completa: revisa la Referencia del lenguaje y la Gram\u00e1tica formal . Desarrollo del compilador: visita Arquitectura y CLI y flujo de compilaci\u00f3n .","title":"\u00bfPor d\u00f3nde empezar?"},{"location":"#estructura-de-la-documentacion","text":"Visi\u00f3n general : identidad, objetivos y conceptos clave. Lenguaje : sintaxis base, ejemplos y gu\u00eda de caracter\u00edsticas. Referencia : operadores, funciones integradas, palabras clave y gram\u00e1tica. Compilador : arquitectura y flujo de compilaci\u00f3n. Construcci\u00f3n e instalaci\u00f3n : pasos por plataforma y generaci\u00f3n de instaladores. Proyecto : estructura del repo, contribuciones y roadmap. Sistemas de ingenier\u00eda : documentos de arquitectura, requisitos y validaci\u00f3n. Recursos : presentaciones y material complementario.","title":"Estructura de la documentaci\u00f3n"},{"location":"#construir-la-documentacion-con-mkdocs","text":"La documentaci\u00f3n est\u00e1 preparada para MkDocs . pip install mkdocs mkdocs serve Luego abre http://127.0.0.1:8000 en tu navegador. Siguiente: Visi\u00f3n general","title":"Construir la documentaci\u00f3n con MkDocs"},{"location":"arquitectura/","text":"Arquitectura del compilador aymc \u00b6 Este documento describe los m\u00f3dulos principales del compilador de AymaraLang y la forma en que se comunican entre s\u00ed. Tambi\u00e9n se explican las estructuras de datos usadas internamente y se presentan ejemplos de la compilaci\u00f3n paso a paso de un programa sencillo. M\u00f3dulos \u00b6 Lexer \u00b6 Ubicaci\u00f3n: compiler/lexer Convierte el c\u00f3digo fuente en una secuencia de tokens . Cada token posee tipo, texto, l\u00ednea y columna ( struct Token ). Reconoce palabras clave en aymara ( si , sino , mientras , etc.), operadores y literales. Parser \u00b6 Ubicaci\u00f3n: compiler/parser Recibe la lista de tokens y produce un \u00c1rbol de Sintaxis Abstracta (AST). Implementa un an\u00e1lisis LL que construye nodos de tipo Expr y Stmt . AST \u00b6 Ubicaci\u00f3n: compiler/ast Conjunto de clases que representan expresiones y sentencias. Los nodos derivan de Node y se visitan mediante el patr\u00f3n visitor ( ASTVisitor ). Ejemplos de nodos: NumberExpr , BinaryExpr , IfStmt , FunctionStmt . An\u00e1lisis sem\u00e1ntico \u00b6 Ubicaci\u00f3n: compiler/semantic Comprueba tipos, \u00e1mbito de variables y llamadas a funciones. Mantiene una pila de tablas de s\u00edmbolos ( scopes ) y genera la lista de variables globales y tipos para la etapa de c\u00f3digo. Generador de c\u00f3digo \u00b6 Ubicaci\u00f3n: compiler/codegen Toma el AST validado y lo transforma en ensamblador NASM para x86_64 . Invoca a nasm y ld (v\u00eda gcc ) para producir el ejecutable .ayn . Runtime \u00b6 Ubicaci\u00f3n: runtime Biblioteca m\u00ednima con funciones de E/S usadas por los programas generados. Flujo de compilaci\u00f3n \u00b6 Fuente (.aym) \u2500\u2500\u25ba Lexer \u2500\u2500\u25ba Parser \u2500\u2500\u25ba AST \u2500\u2500\u25ba An\u00e1lisis sem\u00e1ntico \u2500\u2500\u25ba CodeGen \u2500\u2500\u25ba NASM/ld \u2500\u2500\u25ba Ejecutable (.ayn) Cada etapa toma la salida de la anterior y agrega informaci\u00f3n o transforma la representaci\u00f3n del programa hasta generar c\u00f3digo m\u00e1quina. Estructuras de datos \u00b6 Tokens \u00b6 Definidos en lexer.h : enum class TokenType { Identifier, String, Number, Plus, Minus, ... }; struct Token { TokenType type; std::string text; size_t line; size_t column; }; Nodos del AST \u00b6 Definidos en ast.h . Los m\u00e1s usados son: - Expr / Stmt : clases base. - BinaryExpr , UnaryExpr , CallExpr para expresiones. - PrintStmt , IfStmt , ForStmt , FunctionStmt para sentencias. S\u00edmbolos \u00b6 El analizador sem\u00e1ntico maneja un vector de mapas scopes donde cada mapa asocia nombres a tipos. Esto permite verificar declarciones y usos de variables y funciones. Ejemplo paso a paso \u00b6 Tomemos samples/basics/hola.aym : willt\u2019a\u00f1a(\"Kamisaraki!\"); Lexer genera tokens: KeywordPrint , LParen , String(\"Kamisaraki!\") , RParen , Semicolon . Parser construye un PrintStmt con un StringExpr . An\u00e1lisis sem\u00e1ntico valida que la llamada es correcta. CodeGen produce un archivo NASM que imprime la cadena y genera el ejecutable con nasm y ld . Al ejecutar el binario se obtiene: Kamisaraki! Este mismo flujo aplica a programas m\u00e1s grandes, incluyendo funciones, bucles y estructuras de control. Anterior: Gram\u00e1tica formal | Siguiente: CLI y flujo de compilaci\u00f3n","title":"Arquitectura General"},{"location":"arquitectura/#arquitectura-del-compilador-aymc","text":"Este documento describe los m\u00f3dulos principales del compilador de AymaraLang y la forma en que se comunican entre s\u00ed. Tambi\u00e9n se explican las estructuras de datos usadas internamente y se presentan ejemplos de la compilaci\u00f3n paso a paso de un programa sencillo.","title":"Arquitectura del compilador aymc"},{"location":"arquitectura/#modulos","text":"","title":"M\u00f3dulos"},{"location":"arquitectura/#lexer","text":"Ubicaci\u00f3n: compiler/lexer Convierte el c\u00f3digo fuente en una secuencia de tokens . Cada token posee tipo, texto, l\u00ednea y columna ( struct Token ). Reconoce palabras clave en aymara ( si , sino , mientras , etc.), operadores y literales.","title":"Lexer"},{"location":"arquitectura/#parser","text":"Ubicaci\u00f3n: compiler/parser Recibe la lista de tokens y produce un \u00c1rbol de Sintaxis Abstracta (AST). Implementa un an\u00e1lisis LL que construye nodos de tipo Expr y Stmt .","title":"Parser"},{"location":"arquitectura/#ast","text":"Ubicaci\u00f3n: compiler/ast Conjunto de clases que representan expresiones y sentencias. Los nodos derivan de Node y se visitan mediante el patr\u00f3n visitor ( ASTVisitor ). Ejemplos de nodos: NumberExpr , BinaryExpr , IfStmt , FunctionStmt .","title":"AST"},{"location":"arquitectura/#analisis-semantico","text":"Ubicaci\u00f3n: compiler/semantic Comprueba tipos, \u00e1mbito de variables y llamadas a funciones. Mantiene una pila de tablas de s\u00edmbolos ( scopes ) y genera la lista de variables globales y tipos para la etapa de c\u00f3digo.","title":"An\u00e1lisis sem\u00e1ntico"},{"location":"arquitectura/#generador-de-codigo","text":"Ubicaci\u00f3n: compiler/codegen Toma el AST validado y lo transforma en ensamblador NASM para x86_64 . Invoca a nasm y ld (v\u00eda gcc ) para producir el ejecutable .ayn .","title":"Generador de c\u00f3digo"},{"location":"arquitectura/#runtime","text":"Ubicaci\u00f3n: runtime Biblioteca m\u00ednima con funciones de E/S usadas por los programas generados.","title":"Runtime"},{"location":"arquitectura/#flujo-de-compilacion","text":"Fuente (.aym) \u2500\u2500\u25ba Lexer \u2500\u2500\u25ba Parser \u2500\u2500\u25ba AST \u2500\u2500\u25ba An\u00e1lisis sem\u00e1ntico \u2500\u2500\u25ba CodeGen \u2500\u2500\u25ba NASM/ld \u2500\u2500\u25ba Ejecutable (.ayn) Cada etapa toma la salida de la anterior y agrega informaci\u00f3n o transforma la representaci\u00f3n del programa hasta generar c\u00f3digo m\u00e1quina.","title":"Flujo de compilaci\u00f3n"},{"location":"arquitectura/#estructuras-de-datos","text":"","title":"Estructuras de datos"},{"location":"arquitectura/#tokens","text":"Definidos en lexer.h : enum class TokenType { Identifier, String, Number, Plus, Minus, ... }; struct Token { TokenType type; std::string text; size_t line; size_t column; };","title":"Tokens"},{"location":"arquitectura/#nodos-del-ast","text":"Definidos en ast.h . Los m\u00e1s usados son: - Expr / Stmt : clases base. - BinaryExpr , UnaryExpr , CallExpr para expresiones. - PrintStmt , IfStmt , ForStmt , FunctionStmt para sentencias.","title":"Nodos del AST"},{"location":"arquitectura/#simbolos","text":"El analizador sem\u00e1ntico maneja un vector de mapas scopes donde cada mapa asocia nombres a tipos. Esto permite verificar declarciones y usos de variables y funciones.","title":"S\u00edmbolos"},{"location":"arquitectura/#ejemplo-paso-a-paso","text":"Tomemos samples/basics/hola.aym : willt\u2019a\u00f1a(\"Kamisaraki!\"); Lexer genera tokens: KeywordPrint , LParen , String(\"Kamisaraki!\") , RParen , Semicolon . Parser construye un PrintStmt con un StringExpr . An\u00e1lisis sem\u00e1ntico valida que la llamada es correcta. CodeGen produce un archivo NASM que imprime la cadena y genera el ejecutable con nasm y ld . Al ejecutar el binario se obtiene: Kamisaraki! Este mismo flujo aplica a programas m\u00e1s grandes, incluyendo funciones, bucles y estructuras de control. Anterior: Gram\u00e1tica formal | Siguiente: CLI y flujo de compilaci\u00f3n","title":"Ejemplo paso a paso"},{"location":"aymaraLang/","text":"Referencia del lenguaje \u00b6 Esta referencia describe la sintaxis completa, operadores, palabras clave y funciones integradas de AymaraLang. Est\u00e1 pensada para consulta r\u00e1pida durante el desarrollo. Tipos soportados \u00b6 jach\u2019a \u2192 enteros lliphiphi \u2192 flotantes chuymani \u2192 booleanos qillqa \u2192 cadenas Valores booleanos \u00b6 En aym los literales l\u00f3gicos utilizan vocabulario aymara. La palabra cheka representa verdadero ( true ) y la expresi\u00f3n jan cheka equivale a falso ( false ). Son \u00fatiles para inicializar variables y para las condiciones en estructuras de control. chuymani bandera = cheka; si (bandera) { willt\u2019a\u00f1a(\"activado\"); } chuymani otra = jan cheka; si (otra) { willt\u2019a\u00f1a(\"esto no se imprime\"); } sino { willt\u2019a\u00f1a(\"desactivado\"); } Sintaxis soportada \u00b6 Variables y asignaci\u00f3n. Impresi\u00f3n con willt\u2019a\u00f1a(expr) y write(str) . Control de flujo: si / sino , mientras , hace\u00f1a...mientras , para , tantacha\u00f1a . Funciones con lur\u00e4wi nombre(params) { ... } . Expresiones aritm\u00e9ticas + - * / % ^ y operadores unarios -expr , +expr , !expr . Operadores l\u00f3gicos uka , jan uka , janiwa , comparaciones == != < <= > >= . Comentarios // y /* */ . Lectura de consola con input() . Longitud de cadenas con length() . N\u00fameros aleatorios con random(max) . Pausa de ejecuci\u00f3n con sleep(ms) . Arreglos din\u00e1micos con array(n) , array_get(arr, i) , array_set(arr, i, v) , array_free(arr) , array_length(arr) . Funciones matem\u00e1ticas con sin , cos , tan , asin , acos , atan , sqrt , pow , exp , log , log10 , floor , ceil , round , fabs . Ejemplos de sintaxis \u00b6 Entrada y salida \u00b6 qillqa nombre = input(); willt\u2019a\u00f1a(nombre); Arreglos din\u00e1micos \u00b6 jach\u2019a size = 3; jach\u2019a arr = array(size); array_set(arr, 0, 10); array_set(arr, 1, 20); array_set(arr, 2, 30); willt\u2019a\u00f1a(array_get(arr, 1)); array_free(arr); Funciones y recursividad \u00b6 lur\u00e4wi fact(n) { si (n == 0) { kutiyana(1); } kutiyana(n * fact(n - 1)); } willt\u2019a\u00f1a(fact(5)); Bucle con range \u00b6 La forma para x en range(inicio, fin) simplifica la iteraci\u00f3n sobre rangos num\u00e9ricos. para x en range(0, 4) { willt\u2019a\u00f1a(x); } Este fragmento puede encontrarse en samples/control_flow/range_for.aym . Errores comunes \u00b6 Variable no declarada. Tipos incompatibles en asignaciones o expresiones. Uso de break o continue fuera de bucles. return fuera de una funci\u00f3n. Palabras clave \u00b6 willt\u2019a\u00f1a , write , sleep , array , array_get , array_set , array_free , array_length , sin , cos , tan , asin , acos , atan , sqrt , pow , exp , log , log10 , floor , ceil , round , fabs , si , sino , mientras , hace\u00f1a , para , en , jal\u00f1a , saranta\u00f1a , lur\u00e4wi , kutiyana , tantacha\u00f1a , jamusa , akhamawa , uka , jan uka , janiwa , jach\u2019a , lliphiphi , chuymani , qillqa , input , length , random . Glosario de palabras clave \u00b6 Aimara / Espa\u00f1ol Significado willt\u2019a\u00f1a imprimir write imprimir sin salto si if sino else mientras while hace\u00f1a do para for en in tantacha\u00f1a switch jamusa case akhamawa default jal\u00f1a break saranta\u00f1a continue lur\u00e4wi func kutiyana return jach\u2019a int lliphiphi float chuymani bool qillqa string uka and jan uka or janiwa not Anterior: Gu\u00eda de caracter\u00edsticas | Siguiente: Gram\u00e1tica formal","title":"Referencia"},{"location":"aymaraLang/#referencia-del-lenguaje","text":"Esta referencia describe la sintaxis completa, operadores, palabras clave y funciones integradas de AymaraLang. Est\u00e1 pensada para consulta r\u00e1pida durante el desarrollo.","title":"Referencia del lenguaje"},{"location":"aymaraLang/#tipos-soportados","text":"jach\u2019a \u2192 enteros lliphiphi \u2192 flotantes chuymani \u2192 booleanos qillqa \u2192 cadenas","title":"Tipos soportados"},{"location":"aymaraLang/#valores-booleanos","text":"En aym los literales l\u00f3gicos utilizan vocabulario aymara. La palabra cheka representa verdadero ( true ) y la expresi\u00f3n jan cheka equivale a falso ( false ). Son \u00fatiles para inicializar variables y para las condiciones en estructuras de control. chuymani bandera = cheka; si (bandera) { willt\u2019a\u00f1a(\"activado\"); } chuymani otra = jan cheka; si (otra) { willt\u2019a\u00f1a(\"esto no se imprime\"); } sino { willt\u2019a\u00f1a(\"desactivado\"); }","title":"Valores booleanos"},{"location":"aymaraLang/#sintaxis-soportada","text":"Variables y asignaci\u00f3n. Impresi\u00f3n con willt\u2019a\u00f1a(expr) y write(str) . Control de flujo: si / sino , mientras , hace\u00f1a...mientras , para , tantacha\u00f1a . Funciones con lur\u00e4wi nombre(params) { ... } . Expresiones aritm\u00e9ticas + - * / % ^ y operadores unarios -expr , +expr , !expr . Operadores l\u00f3gicos uka , jan uka , janiwa , comparaciones == != < <= > >= . Comentarios // y /* */ . Lectura de consola con input() . Longitud de cadenas con length() . N\u00fameros aleatorios con random(max) . Pausa de ejecuci\u00f3n con sleep(ms) . Arreglos din\u00e1micos con array(n) , array_get(arr, i) , array_set(arr, i, v) , array_free(arr) , array_length(arr) . Funciones matem\u00e1ticas con sin , cos , tan , asin , acos , atan , sqrt , pow , exp , log , log10 , floor , ceil , round , fabs .","title":"Sintaxis soportada"},{"location":"aymaraLang/#ejemplos-de-sintaxis","text":"","title":"Ejemplos de sintaxis"},{"location":"aymaraLang/#entrada-y-salida","text":"qillqa nombre = input(); willt\u2019a\u00f1a(nombre);","title":"Entrada y salida"},{"location":"aymaraLang/#arreglos-dinamicos","text":"jach\u2019a size = 3; jach\u2019a arr = array(size); array_set(arr, 0, 10); array_set(arr, 1, 20); array_set(arr, 2, 30); willt\u2019a\u00f1a(array_get(arr, 1)); array_free(arr);","title":"Arreglos din\u00e1micos"},{"location":"aymaraLang/#funciones-y-recursividad","text":"lur\u00e4wi fact(n) { si (n == 0) { kutiyana(1); } kutiyana(n * fact(n - 1)); } willt\u2019a\u00f1a(fact(5));","title":"Funciones y recursividad"},{"location":"aymaraLang/#bucle-con-range","text":"La forma para x en range(inicio, fin) simplifica la iteraci\u00f3n sobre rangos num\u00e9ricos. para x en range(0, 4) { willt\u2019a\u00f1a(x); } Este fragmento puede encontrarse en samples/control_flow/range_for.aym .","title":"Bucle con range"},{"location":"aymaraLang/#errores-comunes","text":"Variable no declarada. Tipos incompatibles en asignaciones o expresiones. Uso de break o continue fuera de bucles. return fuera de una funci\u00f3n.","title":"Errores comunes"},{"location":"aymaraLang/#palabras-clave","text":"willt\u2019a\u00f1a , write , sleep , array , array_get , array_set , array_free , array_length , sin , cos , tan , asin , acos , atan , sqrt , pow , exp , log , log10 , floor , ceil , round , fabs , si , sino , mientras , hace\u00f1a , para , en , jal\u00f1a , saranta\u00f1a , lur\u00e4wi , kutiyana , tantacha\u00f1a , jamusa , akhamawa , uka , jan uka , janiwa , jach\u2019a , lliphiphi , chuymani , qillqa , input , length , random .","title":"Palabras clave"},{"location":"aymaraLang/#glosario-de-palabras-clave","text":"Aimara / Espa\u00f1ol Significado willt\u2019a\u00f1a imprimir write imprimir sin salto si if sino else mientras while hace\u00f1a do para for en in tantacha\u00f1a switch jamusa case akhamawa default jal\u00f1a break saranta\u00f1a continue lur\u00e4wi func kutiyana return jach\u2019a int lliphiphi float chuymani bool qillqa string uka and jan uka or janiwa not Anterior: Gu\u00eda de caracter\u00edsticas | Siguiente: Gram\u00e1tica formal","title":"Glosario de palabras clave"},{"location":"build/","text":"Compilaci\u00f3n e instalaci\u00f3n \u00b6 Esta gu\u00eda resume los comandos recomendados para compilar e instalar AymaraLang en las plataformas soportadas. Requisitos \u00b6 Linux: g++ (>=8), nasm , gcc (para enlazar), cmake (>=3.15). Windows: MinGW-w64 ( g++ ), nasm , cmake (o usa build.bat ). CMake (recomendado, multiplataforma) \u00b6 Linux/macOS \u00b6 cmake -S . -B build -DCMAKE_BUILD_TYPE=Release cmake --build build -j Binario resultante: build/bin/aymc . Windows (MinGW Makefiles) \u00b6 cmake -S . -B build -G \"MinGW Makefiles\" -DCMAKE_BUILD_TYPE=Release cmake --build build -j Binario resultante: build/bin/aymc.exe . Uso del compilador \u00b6 Linux/macOS \u00b6 ./build/bin/aymc samples/basics/hola.aym ./build/bin/hola Windows \u00b6 build\\\\bin\\\\aymc.exe samples\\\\basics\\\\hola.aym bin\\\\hola.exe Alternativas legacy \u00b6 Linux: make Windows: build.bat","title":"Compilaci\u00f3n e Instalaci\u00f3n"},{"location":"build/#compilacion-e-instalacion","text":"Esta gu\u00eda resume los comandos recomendados para compilar e instalar AymaraLang en las plataformas soportadas.","title":"Compilaci\u00f3n e instalaci\u00f3n"},{"location":"build/#requisitos","text":"Linux: g++ (>=8), nasm , gcc (para enlazar), cmake (>=3.15). Windows: MinGW-w64 ( g++ ), nasm , cmake (o usa build.bat ).","title":"Requisitos"},{"location":"build/#cmake-recomendado-multiplataforma","text":"","title":"CMake (recomendado, multiplataforma)"},{"location":"build/#linuxmacos","text":"cmake -S . -B build -DCMAKE_BUILD_TYPE=Release cmake --build build -j Binario resultante: build/bin/aymc .","title":"Linux/macOS"},{"location":"build/#windows-mingw-makefiles","text":"cmake -S . -B build -G \"MinGW Makefiles\" -DCMAKE_BUILD_TYPE=Release cmake --build build -j Binario resultante: build/bin/aymc.exe .","title":"Windows (MinGW Makefiles)"},{"location":"build/#uso-del-compilador","text":"","title":"Uso del compilador"},{"location":"build/#linuxmacos_1","text":"./build/bin/aymc samples/basics/hola.aym ./build/bin/hola","title":"Linux/macOS"},{"location":"build/#windows","text":"build\\\\bin\\\\aymc.exe samples\\\\basics\\\\hola.aym bin\\\\hola.exe","title":"Windows"},{"location":"build/#alternativas-legacy","text":"Linux: make Windows: build.bat","title":"Alternativas legacy"},{"location":"compiler/","text":"CLI y flujo de compilaci\u00f3n \u00b6 Esta secci\u00f3n describe c\u00f3mo usar el compilador aymc , sus banderas principales y el flujo de trabajo t\u00edpico al compilar programas .aym . Uso b\u00e1sico \u00b6 ./bin/aymc archivo.aym El compilador genera un ejecutable en bin/ con el mismo nombre del archivo de entrada. Tambi\u00e9n produce archivos intermedios en build/ . El flujo es exclusivamente de compilaci\u00f3n: no hay ejecuci\u00f3n interactiva dentro del compilador. Opciones principales \u00b6 --llvm genera un archivo LLVM IR ( .ll ) con un resumen del AST. --windows fuerza la salida a un ejecutable de Windows ( .exe ). --linux fuerza la salida a un ejecutable de Linux. --seed <valor> fija la semilla del generador aleatorio. Flujo de compilaci\u00f3n \u00b6 Lexer : tokeniza el c\u00f3digo fuente. Parser : construye el AST y valida la estructura. An\u00e1lisis sem\u00e1ntico : verifica tipos, s\u00edmbolos y alcance. Codegen : produce NASM o LLVM IR. Ensamblado y enlace : genera el ejecutable final. Archivos generados \u00b6 build/<nombre>.asm : salida NASM. build/<nombre>.o : objeto ensamblado. bin/<nombre> o bin/<nombre>.exe : ejecutable final. Consejos de depuraci\u00f3n \u00b6 Usa --llvm para inspeccionar el resumen del AST. Si aparece un error de s\u00edmbolos, revisa declaraciones y \u00e1mbito. Para reproducir resultados aleatorios, fija --seed . Anterior: Arquitectura del compilador | Siguiente: Compilaci\u00f3n y uso","title":"CLI y Compilaci\u00f3n"},{"location":"compiler/#cli-y-flujo-de-compilacion","text":"Esta secci\u00f3n describe c\u00f3mo usar el compilador aymc , sus banderas principales y el flujo de trabajo t\u00edpico al compilar programas .aym .","title":"CLI y flujo de compilaci\u00f3n"},{"location":"compiler/#uso-basico","text":"./bin/aymc archivo.aym El compilador genera un ejecutable en bin/ con el mismo nombre del archivo de entrada. Tambi\u00e9n produce archivos intermedios en build/ . El flujo es exclusivamente de compilaci\u00f3n: no hay ejecuci\u00f3n interactiva dentro del compilador.","title":"Uso b\u00e1sico"},{"location":"compiler/#opciones-principales","text":"--llvm genera un archivo LLVM IR ( .ll ) con un resumen del AST. --windows fuerza la salida a un ejecutable de Windows ( .exe ). --linux fuerza la salida a un ejecutable de Linux. --seed <valor> fija la semilla del generador aleatorio.","title":"Opciones principales"},{"location":"compiler/#flujo-de-compilacion","text":"Lexer : tokeniza el c\u00f3digo fuente. Parser : construye el AST y valida la estructura. An\u00e1lisis sem\u00e1ntico : verifica tipos, s\u00edmbolos y alcance. Codegen : produce NASM o LLVM IR. Ensamblado y enlace : genera el ejecutable final.","title":"Flujo de compilaci\u00f3n"},{"location":"compiler/#archivos-generados","text":"build/<nombre>.asm : salida NASM. build/<nombre>.o : objeto ensamblado. bin/<nombre> o bin/<nombre>.exe : ejecutable final.","title":"Archivos generados"},{"location":"compiler/#consejos-de-depuracion","text":"Usa --llvm para inspeccionar el resumen del AST. Si aparece un error de s\u00edmbolos, revisa declaraciones y \u00e1mbito. Para reproducir resultados aleatorios, fija --seed . Anterior: Arquitectura del compilador | Siguiente: Compilaci\u00f3n y uso","title":"Consejos de depuraci\u00f3n"},{"location":"grammar/","text":"Gram\u00e1tica de AymaraLang \u00b6 Este documento describe la gram\u00e1tica actual del lenguaje AymaraLang utilizando notaci\u00f3n EBNF y relaciona cada producci\u00f3n con la implementaci\u00f3n en el parser LL(1) del proyecto. Tambi\u00e9n se enumeran los tokens reconocidos por el analizador l\u00e9xico junto con las referencias al c\u00f3digo fuente donde se definen. Tokens l\u00e9xicos \u00b6 Las siguientes tablas resumen cada TokenType expuesto por el compilador y el lexema que lo activa. Todas las reglas se encuentran implementadas en compiler/lexer/lexer.cpp . Palabras clave \u00b6 Token Lexema(s) aceptado(s) Uso sint\u00e1ctico Referencia KeywordPrint willt\u2019a\u00f1a Sentencia de impresi\u00f3n lexer.cpp#L49-L50 KeywordIf si Condicional if lexer.cpp#L51-L52 KeywordElse sino Rama else / else if lexer.cpp#L53-L54 KeywordWhile mientras Bucle while lexer.cpp#L55-L56 KeywordDo hace\u00f1a Bucle do \u2026 while lexer.cpp#L57-L58 KeywordFor para Bucle for lexer.cpp#L59-L60 KeywordIn en Az\u00facar de for \u2026 in range lexer.cpp#L61-L62 KeywordBreak jal\u00f1a Sentencia break lexer.cpp#L63-L64 KeywordContinue saranta\u00f1a Sentencia continue lexer.cpp#L65-L66 KeywordFunc lur\u00e4wi Definici\u00f3n de funciones lexer.cpp#L67-L68 KeywordReturn kutiyana Sentencia return lexer.cpp#L69-L70 KeywordSwitch tantacha\u00f1a Sentencia switch lexer.cpp#L71-L72 KeywordCase jamusa Cl\u00e1usulas case lexer.cpp#L73-L74 KeywordDefault akhamawa Cl\u00e1usula default lexer.cpp#L75-L76 KeywordAnd uka Operador l\u00f3gico AND lexer.cpp#L77-L78 KeywordOr jan uka Operador l\u00f3gico OR compuesto lexer.cpp#L79-L100 KeywordNot janiwa Operador l\u00f3gico NOT lexer.cpp#L103-L104 KeywordInt jach\u2019a Declaraci\u00f3n de enteros lexer.cpp#L105-L106 KeywordFloat lliphiphi Declaraci\u00f3n de flotantes lexer.cpp#L107-L108 KeywordBool chuymani Declaraci\u00f3n de booleanos lexer.cpp#L109-L110 KeywordString qillqa Declaraci\u00f3n de cadenas lexer.cpp#L111-L112 KeywordImport apu Importaci\u00f3n de m\u00f3dulos lexer.cpp#L113-L114 Operadores y delimitadores \u00b6 Token Lexema Referencia Plus + lexer.cpp#L165 Minus - lexer.cpp#L166 Star * lexer.cpp#L167 Slash / lexer.cpp#L168 Percent % lexer.cpp#L169 Caret ^ lexer.cpp#L170 AmpAmp && lexer.cpp#L171-L175 PipePipe || lexer.cpp#L179-L183 Bang ! lexer.cpp#L187-L194 Equal = lexer.cpp#L196-L203 EqualEqual == lexer.cpp#L196-L203 BangEqual != lexer.cpp#L187-L194 Less < lexer.cpp#L205-L212 LessEqual <= lexer.cpp#L205-L212 Greater > lexer.cpp#L214-L221 GreaterEqual >= lexer.cpp#L214-L221 LParen ( lexer.cpp#L223 RParen ) lexer.cpp#L224 LBrace { lexer.cpp#L225 RBrace } lexer.cpp#L226 LBracket [ lexer.cpp#L227 RBracket ] lexer.cpp#L228 Colon : lexer.cpp#L229 Comma , lexer.cpp#L230 Semicolon ; lexer.cpp#L231 Identificadores, literales y control \u00b6 Token Descripci\u00f3n Referencia Identifier Secuencia alfanum\u00e9rica (permite UTF-8 y _ ) que no coincide con palabra reservada lexer.cpp#L39-L47 Number Literales num\u00e9ricos decimales, adem\u00e1s de los az\u00facares cheka (=1) y jan cheka (=0) lexer.cpp#L79-L129 String Literales de cadena entre comillas dobles con escapes ( \\n , \\t , \\\" , etc.) lexer.cpp#L132-L161 EndOfFile Marcador al final de la tokenizaci\u00f3n lexer.cpp#L236-L237 Nota: Los tokens LBracket y RBracket a\u00fan no se emplean en producciones del parser, pero quedan reservados para futuras extensiones (p.ej. arreglos). Notaci\u00f3n EBNF utilizada \u00b6 a* indica repetici\u00f3n de cero o m\u00e1s veces. a+ indica una o m\u00e1s repeticiones. [a] marca un elemento opcional. a | b representa alternativas. Los literales de palabra clave se escriben con comillas ( \"lexema\" ). Gram\u00e1tica sint\u00e1ctica \u00b6 Programa y bloques \u00b6 program ::= statement* EOF ; block ::= \"{\" statement* \"}\" ; Estas producciones corresponden a Parser::parse y Parser::parseStatements , que reutilizan la misma rutina para cuerpos delimitados por llaves ( block ). Cuando parseStatements se invoca con stopAtBrace = true consume el RBrace final. Sentencias \u00b6 Cada alternativa de statement proviene de Parser::parseSingleStatement . A continuaci\u00f3n se detalla la sintaxis concreta de cada forma: statement ::= importStmt | varDecl | returnStmt | breakStmt | continueStmt | printStmt | ifStmt | whileStmt | doWhileStmt | forRangeStmt | forClassicStmt | switchStmt | functionStmt | assignmentStmt | exprStmt ; Importaciones \u00b6 importStmt ::= \"apu\" (Identifier | String) \";\" ; Implementado en parseSingleStatement . Declaraciones de variables \u00b6 varDecl ::= typeKeyword Identifier [\"=\" expression] \";\" ; typeKeyword ::= \"jach\u2019a\" | \"lliphiphi\" | \"chuymani\" | \"qillqa\" ; Corresponde a parseSingleStatement . Sentencias de retorno y control de bucle \u00b6 returnStmt ::= \"kutiyana\" [expression] \";\" ; breakStmt ::= \"jal\u00f1a\" \";\" ; continueStmt ::= \"saranta\u00f1a\" \";\" ; Ver parser.cpp#L83-L107 . Impresi\u00f3n \u00b6 printStmt ::= \"willt\u2019a\u00f1a\" \"(\" expression \")\" \";\" ; Implementado en parser.cpp#L109-L118 . Condicionales \u00b6 ifStmt ::= \"si\" \"(\" expression \")\" block [elseClause] ; elseClause ::= \"sino\" (block | ifStmt) ; Refleja parser.cpp#L120-L151 , que anida if sucesivos para soportar sino si . Bucles while y do \u2026 while \u00b6 whileStmt ::= \"mientras\" \"(\" expression \")\" block ; doWhileStmt ::= \"hace\u00f1a\" block \"mientras\" \"(\" expression \")\" \";\" ; Implementaci\u00f3n en parser.cpp#L153-L184 . Bucles for \u00b6 forRangeStmt ::= \"para\" Identifier \"en\" \"range\" \"(\" expression \",\" expression \")\" block ; forClassicStmt ::= \"para\" \"(\" statement expression \";\" statement \")\" block ; Ambas variantes viven en parser.cpp#L186-L233 . La forma cl\u00e1sica reutiliza statement para las secciones de inicializaci\u00f3n y post-procesamiento, lo que implica que dichas porciones incluyen su propio \";\" antes de continuar con el resto del encabezado. Sentencia switch \u00b6 switchStmt ::= \"tantacha\u00f1a\" \"(\" expression \")\" \"{\" caseClause* [defaultClause] \"}\" ; caseClause ::= \"jamusa\" expression \":\" statement* ; defaultClause ::= \"akhamawa\" \":\" statement* ; Implementaci\u00f3n en parser.cpp#L235-L273 . Definiciones de funciones \u00b6 functionStmt ::= \"lur\u00e4wi\" [Identifier] \"(\" parameterList? \")\" block ; parameterList ::= Identifier (\",\" Identifier)* ; Definido en parser.cpp#L276-L295 . El nombre es opcional y los par\u00e1metros se reconocen como identificadores desnudos. Asignaciones y expresiones \u00b6 assignmentStmt ::= Identifier \"=\" expression \";\" ; exprStmt ::= expression \";\" ; Generadas por parser.cpp#L297-L318 . Cuando un identificador no est\u00e1 seguido de = , la sentencia se degrada a una expresi\u00f3n pura. Expresiones \u00b6 La jerarqu\u00eda de expresiones est\u00e1 factorada en m\u00e9todos dedicados dentro de Parser . Todas las producciones terminan referenciando parseFactor y parseArguments . expression ::= logicalExpr ; logicalExpr ::= equalityExpr { logicalOp equalityExpr } ; logicalOp ::= \"uka\" | \"&&\" | \"jan uka\" | \"||\" ; equalityExpr ::= comparisonExpr { (\"==\" | \"!=\") comparisonExpr } ; comparisonExpr ::= additiveExpr { (\"<\" | \"<=\" | \">\" | \">=\") additiveExpr } ; additiveExpr ::= multiplicativeExpr { (\"+\" | \"-\") multiplicativeExpr } ; multiplicativeExpr ::= powerExpr { (\"*\" | \"/\" | \"%\") powerExpr } ; powerExpr ::= unaryExpr { \"^\" unaryExpr } ; unaryExpr ::= (\"-\" | \"+\" | \"janiwa\" | \"!\") unaryExpr | primaryExpr ; primaryExpr ::= Number | String | Identifier [\"(\" argumentList? \")\"] | \"(\" expression \")\" ; argumentList ::= expression { \",\" expression } ; logicalExpr y sus operadores se derivan de parseLogic . equalityExpr proviene de parseEquality . comparisonExpr est\u00e1 en parseComparison . additiveExpr , multiplicativeExpr y powerExpr se corresponden con parseAdd , parseTerm y parsePower respectivamente. unaryExpr y primaryExpr se implementan en parseFactor . argumentList reusa parseArguments . Los literales Number incluyen tanto cifras decimales como los az\u00facares cheka y jan cheka definidos en el lexer. Las llamadas a funciones requieren que el calificador sea un Identifier ; las palabras reservadas no pueden emplearse como nombres v\u00e1lidos. Tokens finales \u00b6 El flujo sint\u00e1ctico concluye cuando se consume el token EndOfFile , a\u00f1adido expl\u00edcitamente por el lexer en lexer.cpp#L236-L237 y verificado por el parser durante la iteraci\u00f3n principal. Este documento debe mantenerse sincronizado con el c\u00f3digo fuente para reflejar cualquier cambio en la gram\u00e1tica del lenguaje. Anterior: Referencia del lenguaje | Siguiente: Arquitectura del compilador","title":"Gram\u00e1tica formal"},{"location":"grammar/#gramatica-de-aymaralang","text":"Este documento describe la gram\u00e1tica actual del lenguaje AymaraLang utilizando notaci\u00f3n EBNF y relaciona cada producci\u00f3n con la implementaci\u00f3n en el parser LL(1) del proyecto. Tambi\u00e9n se enumeran los tokens reconocidos por el analizador l\u00e9xico junto con las referencias al c\u00f3digo fuente donde se definen.","title":"Gram\u00e1tica de AymaraLang"},{"location":"grammar/#tokens-lexicos","text":"Las siguientes tablas resumen cada TokenType expuesto por el compilador y el lexema que lo activa. Todas las reglas se encuentran implementadas en compiler/lexer/lexer.cpp .","title":"Tokens l\u00e9xicos"},{"location":"grammar/#palabras-clave","text":"Token Lexema(s) aceptado(s) Uso sint\u00e1ctico Referencia KeywordPrint willt\u2019a\u00f1a Sentencia de impresi\u00f3n lexer.cpp#L49-L50 KeywordIf si Condicional if lexer.cpp#L51-L52 KeywordElse sino Rama else / else if lexer.cpp#L53-L54 KeywordWhile mientras Bucle while lexer.cpp#L55-L56 KeywordDo hace\u00f1a Bucle do \u2026 while lexer.cpp#L57-L58 KeywordFor para Bucle for lexer.cpp#L59-L60 KeywordIn en Az\u00facar de for \u2026 in range lexer.cpp#L61-L62 KeywordBreak jal\u00f1a Sentencia break lexer.cpp#L63-L64 KeywordContinue saranta\u00f1a Sentencia continue lexer.cpp#L65-L66 KeywordFunc lur\u00e4wi Definici\u00f3n de funciones lexer.cpp#L67-L68 KeywordReturn kutiyana Sentencia return lexer.cpp#L69-L70 KeywordSwitch tantacha\u00f1a Sentencia switch lexer.cpp#L71-L72 KeywordCase jamusa Cl\u00e1usulas case lexer.cpp#L73-L74 KeywordDefault akhamawa Cl\u00e1usula default lexer.cpp#L75-L76 KeywordAnd uka Operador l\u00f3gico AND lexer.cpp#L77-L78 KeywordOr jan uka Operador l\u00f3gico OR compuesto lexer.cpp#L79-L100 KeywordNot janiwa Operador l\u00f3gico NOT lexer.cpp#L103-L104 KeywordInt jach\u2019a Declaraci\u00f3n de enteros lexer.cpp#L105-L106 KeywordFloat lliphiphi Declaraci\u00f3n de flotantes lexer.cpp#L107-L108 KeywordBool chuymani Declaraci\u00f3n de booleanos lexer.cpp#L109-L110 KeywordString qillqa Declaraci\u00f3n de cadenas lexer.cpp#L111-L112 KeywordImport apu Importaci\u00f3n de m\u00f3dulos lexer.cpp#L113-L114","title":"Palabras clave"},{"location":"grammar/#operadores-y-delimitadores","text":"Token Lexema Referencia Plus + lexer.cpp#L165 Minus - lexer.cpp#L166 Star * lexer.cpp#L167 Slash / lexer.cpp#L168 Percent % lexer.cpp#L169 Caret ^ lexer.cpp#L170 AmpAmp && lexer.cpp#L171-L175 PipePipe || lexer.cpp#L179-L183 Bang ! lexer.cpp#L187-L194 Equal = lexer.cpp#L196-L203 EqualEqual == lexer.cpp#L196-L203 BangEqual != lexer.cpp#L187-L194 Less < lexer.cpp#L205-L212 LessEqual <= lexer.cpp#L205-L212 Greater > lexer.cpp#L214-L221 GreaterEqual >= lexer.cpp#L214-L221 LParen ( lexer.cpp#L223 RParen ) lexer.cpp#L224 LBrace { lexer.cpp#L225 RBrace } lexer.cpp#L226 LBracket [ lexer.cpp#L227 RBracket ] lexer.cpp#L228 Colon : lexer.cpp#L229 Comma , lexer.cpp#L230 Semicolon ; lexer.cpp#L231","title":"Operadores y delimitadores"},{"location":"grammar/#identificadores-literales-y-control","text":"Token Descripci\u00f3n Referencia Identifier Secuencia alfanum\u00e9rica (permite UTF-8 y _ ) que no coincide con palabra reservada lexer.cpp#L39-L47 Number Literales num\u00e9ricos decimales, adem\u00e1s de los az\u00facares cheka (=1) y jan cheka (=0) lexer.cpp#L79-L129 String Literales de cadena entre comillas dobles con escapes ( \\n , \\t , \\\" , etc.) lexer.cpp#L132-L161 EndOfFile Marcador al final de la tokenizaci\u00f3n lexer.cpp#L236-L237 Nota: Los tokens LBracket y RBracket a\u00fan no se emplean en producciones del parser, pero quedan reservados para futuras extensiones (p.ej. arreglos).","title":"Identificadores, literales y control"},{"location":"grammar/#notacion-ebnf-utilizada","text":"a* indica repetici\u00f3n de cero o m\u00e1s veces. a+ indica una o m\u00e1s repeticiones. [a] marca un elemento opcional. a | b representa alternativas. Los literales de palabra clave se escriben con comillas ( \"lexema\" ).","title":"Notaci\u00f3n EBNF utilizada"},{"location":"grammar/#gramatica-sintactica","text":"","title":"Gram\u00e1tica sint\u00e1ctica"},{"location":"grammar/#programa-y-bloques","text":"program ::= statement* EOF ; block ::= \"{\" statement* \"}\" ; Estas producciones corresponden a Parser::parse y Parser::parseStatements , que reutilizan la misma rutina para cuerpos delimitados por llaves ( block ). Cuando parseStatements se invoca con stopAtBrace = true consume el RBrace final.","title":"Programa y bloques"},{"location":"grammar/#sentencias","text":"Cada alternativa de statement proviene de Parser::parseSingleStatement . A continuaci\u00f3n se detalla la sintaxis concreta de cada forma: statement ::= importStmt | varDecl | returnStmt | breakStmt | continueStmt | printStmt | ifStmt | whileStmt | doWhileStmt | forRangeStmt | forClassicStmt | switchStmt | functionStmt | assignmentStmt | exprStmt ;","title":"Sentencias"},{"location":"grammar/#importaciones","text":"importStmt ::= \"apu\" (Identifier | String) \";\" ; Implementado en parseSingleStatement .","title":"Importaciones"},{"location":"grammar/#declaraciones-de-variables","text":"varDecl ::= typeKeyword Identifier [\"=\" expression] \";\" ; typeKeyword ::= \"jach\u2019a\" | \"lliphiphi\" | \"chuymani\" | \"qillqa\" ; Corresponde a parseSingleStatement .","title":"Declaraciones de variables"},{"location":"grammar/#sentencias-de-retorno-y-control-de-bucle","text":"returnStmt ::= \"kutiyana\" [expression] \";\" ; breakStmt ::= \"jal\u00f1a\" \";\" ; continueStmt ::= \"saranta\u00f1a\" \";\" ; Ver parser.cpp#L83-L107 .","title":"Sentencias de retorno y control de bucle"},{"location":"grammar/#impresion","text":"printStmt ::= \"willt\u2019a\u00f1a\" \"(\" expression \")\" \";\" ; Implementado en parser.cpp#L109-L118 .","title":"Impresi\u00f3n"},{"location":"grammar/#condicionales","text":"ifStmt ::= \"si\" \"(\" expression \")\" block [elseClause] ; elseClause ::= \"sino\" (block | ifStmt) ; Refleja parser.cpp#L120-L151 , que anida if sucesivos para soportar sino si .","title":"Condicionales"},{"location":"grammar/#bucles-while-y-do-while","text":"whileStmt ::= \"mientras\" \"(\" expression \")\" block ; doWhileStmt ::= \"hace\u00f1a\" block \"mientras\" \"(\" expression \")\" \";\" ; Implementaci\u00f3n en parser.cpp#L153-L184 .","title":"Bucles while y do \u2026 while"},{"location":"grammar/#bucles-for","text":"forRangeStmt ::= \"para\" Identifier \"en\" \"range\" \"(\" expression \",\" expression \")\" block ; forClassicStmt ::= \"para\" \"(\" statement expression \";\" statement \")\" block ; Ambas variantes viven en parser.cpp#L186-L233 . La forma cl\u00e1sica reutiliza statement para las secciones de inicializaci\u00f3n y post-procesamiento, lo que implica que dichas porciones incluyen su propio \";\" antes de continuar con el resto del encabezado.","title":"Bucles for"},{"location":"grammar/#sentencia-switch","text":"switchStmt ::= \"tantacha\u00f1a\" \"(\" expression \")\" \"{\" caseClause* [defaultClause] \"}\" ; caseClause ::= \"jamusa\" expression \":\" statement* ; defaultClause ::= \"akhamawa\" \":\" statement* ; Implementaci\u00f3n en parser.cpp#L235-L273 .","title":"Sentencia switch"},{"location":"grammar/#definiciones-de-funciones","text":"functionStmt ::= \"lur\u00e4wi\" [Identifier] \"(\" parameterList? \")\" block ; parameterList ::= Identifier (\",\" Identifier)* ; Definido en parser.cpp#L276-L295 . El nombre es opcional y los par\u00e1metros se reconocen como identificadores desnudos.","title":"Definiciones de funciones"},{"location":"grammar/#asignaciones-y-expresiones","text":"assignmentStmt ::= Identifier \"=\" expression \";\" ; exprStmt ::= expression \";\" ; Generadas por parser.cpp#L297-L318 . Cuando un identificador no est\u00e1 seguido de = , la sentencia se degrada a una expresi\u00f3n pura.","title":"Asignaciones y expresiones"},{"location":"grammar/#expresiones","text":"La jerarqu\u00eda de expresiones est\u00e1 factorada en m\u00e9todos dedicados dentro de Parser . Todas las producciones terminan referenciando parseFactor y parseArguments . expression ::= logicalExpr ; logicalExpr ::= equalityExpr { logicalOp equalityExpr } ; logicalOp ::= \"uka\" | \"&&\" | \"jan uka\" | \"||\" ; equalityExpr ::= comparisonExpr { (\"==\" | \"!=\") comparisonExpr } ; comparisonExpr ::= additiveExpr { (\"<\" | \"<=\" | \">\" | \">=\") additiveExpr } ; additiveExpr ::= multiplicativeExpr { (\"+\" | \"-\") multiplicativeExpr } ; multiplicativeExpr ::= powerExpr { (\"*\" | \"/\" | \"%\") powerExpr } ; powerExpr ::= unaryExpr { \"^\" unaryExpr } ; unaryExpr ::= (\"-\" | \"+\" | \"janiwa\" | \"!\") unaryExpr | primaryExpr ; primaryExpr ::= Number | String | Identifier [\"(\" argumentList? \")\"] | \"(\" expression \")\" ; argumentList ::= expression { \",\" expression } ; logicalExpr y sus operadores se derivan de parseLogic . equalityExpr proviene de parseEquality . comparisonExpr est\u00e1 en parseComparison . additiveExpr , multiplicativeExpr y powerExpr se corresponden con parseAdd , parseTerm y parsePower respectivamente. unaryExpr y primaryExpr se implementan en parseFactor . argumentList reusa parseArguments . Los literales Number incluyen tanto cifras decimales como los az\u00facares cheka y jan cheka definidos en el lexer. Las llamadas a funciones requieren que el calificador sea un Identifier ; las palabras reservadas no pueden emplearse como nombres v\u00e1lidos.","title":"Expresiones"},{"location":"grammar/#tokens-finales","text":"El flujo sint\u00e1ctico concluye cuando se consume el token EndOfFile , a\u00f1adido expl\u00edcitamente por el lexer en lexer.cpp#L236-L237 y verificado por el parser durante la iteraci\u00f3n principal. Este documento debe mantenerse sincronizado con el c\u00f3digo fuente para reflejar cualquier cambio en la gram\u00e1tica del lenguaje. Anterior: Referencia del lenguaje | Siguiente: Arquitectura del compilador","title":"Tokens finales"},{"location":"guide/","text":"Gu\u00eda de caracter\u00edsticas \u00b6 Esta gu\u00eda agrupa las funcionalidades m\u00e1s usadas de AymaraLang con ejemplos. Variables string \u00b6 qillqa saludo = \"Kamisaraki\"; willt\u2019a\u00f1a(saludo); Operaciones aritm\u00e9ticas \u00b6 Soporta % (m\u00f3dulo) y ^ (potencia de enteros). willt\u2019a\u00f1a(5 % 2); willt\u2019a\u00f1a(2 ^ 3); Switch-Case \u00b6 valor = 2; tantacha\u00f1a(valor) { jamusa 1 { willt\u2019a\u00f1a(\"uno\"); } jamusa 2 { willt\u2019a\u00f1a(\"dos\"); } akhamawa { willt\u2019a\u00f1a(\"otro\"); } } Operadores l\u00f3gicos \u00b6 Se admiten uka , jan uka y janiwa . si (1 uka janiwa 0) { willt\u2019a\u00f1a(\"ok\"); } Comentarios \u00b6 Usa // para comentarios de l\u00ednea y /* ... */ para bloques. Lectura con input() \u00b6 jach\u2019a numero = input(); willt\u2019a\u00f1a(numero); Comparaciones \u00b6 si (5 >= 3) { willt\u2019a\u00f1a(\"mayor\"); } M\u00f3dulos ( apu ) \u00b6 Desde ahora es posible dividir el c\u00f3digo en varios archivos y reutilizarlo con la declaraci\u00f3n apu . apu \"modules/aritmetica\"; jach\u2019a total = suma(3, 4); willt\u2019a\u00f1a(total); Coloca el archivo modules/aritmetica.aym junto al programa o dentro de una carpeta modules/ . El resolvedor busca m\u00f3dulos en: El directorio del archivo principal. Una carpeta modules/ dentro de ese directorio. Rutas adicionales indicadas en la variable de entorno AYM_PATH . Cada m\u00f3dulo se procesa una sola vez y puede importar a su vez otros m\u00f3dulos con apu . Arreglos din\u00e1micos \u00b6 jach\u2019a n = 5; jach\u2019a arr = array(n); array_set(arr, 0, 10); willt\u2019a\u00f1a(array_get(arr, 0)); willt\u2019a\u00f1a(array_length(arr)); array_free(arr); Funciones matem\u00e1ticas \u00b6 lliphiphi ang = 1.57; willt\u2019a\u00f1a(sin(ang)); willt\u2019a\u00f1a(sqrt(9)); Anterior: Primeros pasos | Siguiente: Referencia del lenguaje","title":"Gu\u00eda de caracter\u00edsticas"},{"location":"guide/#guia-de-caracteristicas","text":"Esta gu\u00eda agrupa las funcionalidades m\u00e1s usadas de AymaraLang con ejemplos.","title":"Gu\u00eda de caracter\u00edsticas"},{"location":"guide/#variables-string","text":"qillqa saludo = \"Kamisaraki\"; willt\u2019a\u00f1a(saludo);","title":"Variables string"},{"location":"guide/#operaciones-aritmeticas","text":"Soporta % (m\u00f3dulo) y ^ (potencia de enteros). willt\u2019a\u00f1a(5 % 2); willt\u2019a\u00f1a(2 ^ 3);","title":"Operaciones aritm\u00e9ticas"},{"location":"guide/#switch-case","text":"valor = 2; tantacha\u00f1a(valor) { jamusa 1 { willt\u2019a\u00f1a(\"uno\"); } jamusa 2 { willt\u2019a\u00f1a(\"dos\"); } akhamawa { willt\u2019a\u00f1a(\"otro\"); } }","title":"Switch-Case"},{"location":"guide/#operadores-logicos","text":"Se admiten uka , jan uka y janiwa . si (1 uka janiwa 0) { willt\u2019a\u00f1a(\"ok\"); }","title":"Operadores l\u00f3gicos"},{"location":"guide/#comentarios","text":"Usa // para comentarios de l\u00ednea y /* ... */ para bloques.","title":"Comentarios"},{"location":"guide/#lectura-con-input","text":"jach\u2019a numero = input(); willt\u2019a\u00f1a(numero);","title":"Lectura con input()"},{"location":"guide/#comparaciones","text":"si (5 >= 3) { willt\u2019a\u00f1a(\"mayor\"); }","title":"Comparaciones"},{"location":"guide/#modulos-apu","text":"Desde ahora es posible dividir el c\u00f3digo en varios archivos y reutilizarlo con la declaraci\u00f3n apu . apu \"modules/aritmetica\"; jach\u2019a total = suma(3, 4); willt\u2019a\u00f1a(total); Coloca el archivo modules/aritmetica.aym junto al programa o dentro de una carpeta modules/ . El resolvedor busca m\u00f3dulos en: El directorio del archivo principal. Una carpeta modules/ dentro de ese directorio. Rutas adicionales indicadas en la variable de entorno AYM_PATH . Cada m\u00f3dulo se procesa una sola vez y puede importar a su vez otros m\u00f3dulos con apu .","title":"M\u00f3dulos (apu)"},{"location":"guide/#arreglos-dinamicos","text":"jach\u2019a n = 5; jach\u2019a arr = array(n); array_set(arr, 0, 10); willt\u2019a\u00f1a(array_get(arr, 0)); willt\u2019a\u00f1a(array_length(arr)); array_free(arr);","title":"Arreglos din\u00e1micos"},{"location":"guide/#funciones-matematicas","text":"lliphiphi ang = 1.57; willt\u2019a\u00f1a(sin(ang)); willt\u2019a\u00f1a(sqrt(9)); Anterior: Primeros pasos | Siguiente: Referencia del lenguaje","title":"Funciones matem\u00e1ticas"},{"location":"indice/","text":"Documentaci\u00f3n de AymaraLang \u00b6 Este \u00edndice agrupa la documentaci\u00f3n principal del proyecto. Cada documento est\u00e1 pensado para ser breve y directo, as\u00ed puedes leer solo lo que necesitas. \u00cdndice \u00b6 Gu\u00edas introductorias \u00b6 Visi\u00f3n general Lenguaje \u00b6 Primeros pasos Gu\u00eda de caracter\u00edsticas Referencia del lenguaje Gram\u00e1tica formal Compilador \u00b6 Arquitectura del compilador CLI y flujo de compilaci\u00f3n Construcci\u00f3n e instalaci\u00f3n \u00b6 Compilaci\u00f3n e instalaci\u00f3n Instaladores Proyecto \u00b6 Gu\u00eda del proyecto Sistemas de ingenier\u00eda \u00b6 Arquitectura CONOPS Documento de control de interfaces Requisitos Gesti\u00f3n de riesgos Plan de gesti\u00f3n Verificaci\u00f3n y validaci\u00f3n","title":"\u00cdndice r\u00e1pido"},{"location":"indice/#documentacion-de-aymaralang","text":"Este \u00edndice agrupa la documentaci\u00f3n principal del proyecto. Cada documento est\u00e1 pensado para ser breve y directo, as\u00ed puedes leer solo lo que necesitas.","title":"Documentaci\u00f3n de AymaraLang"},{"location":"indice/#indice","text":"","title":"\u00cdndice"},{"location":"indice/#guias-introductorias","text":"Visi\u00f3n general","title":"Gu\u00edas introductorias"},{"location":"indice/#lenguaje","text":"Primeros pasos Gu\u00eda de caracter\u00edsticas Referencia del lenguaje Gram\u00e1tica formal","title":"Lenguaje"},{"location":"indice/#compilador","text":"Arquitectura del compilador CLI y flujo de compilaci\u00f3n","title":"Compilador"},{"location":"indice/#construccion-e-instalacion","text":"Compilaci\u00f3n e instalaci\u00f3n Instaladores","title":"Construcci\u00f3n e instalaci\u00f3n"},{"location":"indice/#proyecto","text":"Gu\u00eda del proyecto","title":"Proyecto"},{"location":"indice/#sistemas-de-ingenieria","text":"Arquitectura CONOPS Documento de control de interfaces Requisitos Gesti\u00f3n de riesgos Plan de gesti\u00f3n Verificaci\u00f3n y validaci\u00f3n","title":"Sistemas de ingenier\u00eda"},{"location":"installers/","text":"Instaladores y binarios \u00b6 Este documento describe c\u00f3mo generar instaladores para Windows, Linux y macOS, adem\u00e1s de c\u00f3mo producir binarios listos para distribuci\u00f3n con CPack. Requisitos generales \u00b6 CMake >= 3.15 Compilador C++17 ( g++ , clang++ o MSVC) nasm y gcc / ld para el ensamblado y enlace en Linux/Windows (MinGW) Paquetes de desarrollo de LLVM si se usa --llvm Flujo base (todas las plataformas) \u00b6 cmake -S . -B build -DCMAKE_BUILD_TYPE=Release cmake --build build -j Los binarios compilados quedar\u00e1n en build/bin/aymc . Windows (instalador tipo asistente con NSIS) \u00b6 Instala CMake y el generador de NSIS (https://nsis.sourceforge.io/). Compila con CMake: powershell cmake -S . -B build -G \"Ninja\" -DCMAKE_BUILD_TYPE=Release cmake --build build -j Genera el instalador: powershell cd build cpack -G NSIS El instalador .exe ofrece un asistente gr\u00e1fico similar al de Python/Java, permite instalar en Program Files , crea accesos en el men\u00fa Inicio y puede a\u00f1adir aymc al PATH . Linux (binarios y paquetes) \u00b6 Compila con CMake. Genera paquetes: bash cd build cpack -G TGZ cpack -G DEB cpack -G RPM Los paquetes generados contienen bin/aymc y los archivos de runtime en share/aymaraLang/runtime . macOS (DMG) \u00b6 Compila con CMake usando clang++ (Homebrew LLVM recomendado). Genera el DMG: bash cd build cpack -G DragNDrop El DMG empaqueta el binario aymc y el runtime. Anterior: Compilaci\u00f3n y uso | Siguiente: Gu\u00eda del proyecto","title":"Instaladores"},{"location":"installers/#instaladores-y-binarios","text":"Este documento describe c\u00f3mo generar instaladores para Windows, Linux y macOS, adem\u00e1s de c\u00f3mo producir binarios listos para distribuci\u00f3n con CPack.","title":"Instaladores y binarios"},{"location":"installers/#requisitos-generales","text":"CMake >= 3.15 Compilador C++17 ( g++ , clang++ o MSVC) nasm y gcc / ld para el ensamblado y enlace en Linux/Windows (MinGW) Paquetes de desarrollo de LLVM si se usa --llvm","title":"Requisitos generales"},{"location":"installers/#flujo-base-todas-las-plataformas","text":"cmake -S . -B build -DCMAKE_BUILD_TYPE=Release cmake --build build -j Los binarios compilados quedar\u00e1n en build/bin/aymc .","title":"Flujo base (todas las plataformas)"},{"location":"installers/#windows-instalador-tipo-asistente-con-nsis","text":"Instala CMake y el generador de NSIS (https://nsis.sourceforge.io/). Compila con CMake: powershell cmake -S . -B build -G \"Ninja\" -DCMAKE_BUILD_TYPE=Release cmake --build build -j Genera el instalador: powershell cd build cpack -G NSIS El instalador .exe ofrece un asistente gr\u00e1fico similar al de Python/Java, permite instalar en Program Files , crea accesos en el men\u00fa Inicio y puede a\u00f1adir aymc al PATH .","title":"Windows (instalador tipo asistente con NSIS)"},{"location":"installers/#linux-binarios-y-paquetes","text":"Compila con CMake. Genera paquetes: bash cd build cpack -G TGZ cpack -G DEB cpack -G RPM Los paquetes generados contienen bin/aymc y los archivos de runtime en share/aymaraLang/runtime .","title":"Linux (binarios y paquetes)"},{"location":"installers/#macos-dmg","text":"Compila con CMake usando clang++ (Homebrew LLVM recomendado). Genera el DMG: bash cd build cpack -G DragNDrop El DMG empaqueta el binario aymc y el runtime. Anterior: Compilaci\u00f3n y uso | Siguiente: Gu\u00eda del proyecto","title":"macOS (DMG)"},{"location":"language/","text":"Primeros pasos con AymaraLang \u00b6 Esta secci\u00f3n introduce la sintaxis b\u00e1sica del lenguaje con ejemplos cortos. Si buscas detalles exhaustivos de operadores y funciones integradas, consulta la Referencia del lenguaje . Hola mundo \u00b6 willt\u2019a\u00f1a(\"Kamisaraki!\"); Tipos y variables \u00b6 jach\u2019a contador = 3; lliphiphi promedio = 3.14; qillqa saludo = \"kamisaraki\"; chuymani activo = cheka; Condicionales \u00b6 si (contador > 0) { willt\u2019a\u00f1a(saludo); } sino { willt\u2019a\u00f1a(\"janiwa\"); } Bucles \u00b6 para i en range(0, 3) { willt\u2019a\u00f1a(i); } mientras (contador > 0) { contador = contador - 1; } Funciones \u00b6 lur\u00e4wi inc(n) { kutiyana n + 1; } willt\u2019a\u00f1a(inc(5)); M\u00f3dulos \u00b6 apu \"modules/aritmetica\"; willt\u2019a\u00f1a(\"suma: \" + suma(3, 4)); Los m\u00f3dulos se resuelven desde el directorio del archivo principal, desde una carpeta modules/ y desde rutas adicionales definidas en la variable de entorno AYM_PATH . Comentarios \u00b6 # comentario estilo aym // comentario estilo C /* bloque de comentario */ Anterior: Visi\u00f3n general | Siguiente: Gu\u00eda de caracter\u00edsticas","title":"Primeros pasos"},{"location":"language/#primeros-pasos-con-aymaralang","text":"Esta secci\u00f3n introduce la sintaxis b\u00e1sica del lenguaje con ejemplos cortos. Si buscas detalles exhaustivos de operadores y funciones integradas, consulta la Referencia del lenguaje .","title":"Primeros pasos con AymaraLang"},{"location":"language/#hola-mundo","text":"willt\u2019a\u00f1a(\"Kamisaraki!\");","title":"Hola mundo"},{"location":"language/#tipos-y-variables","text":"jach\u2019a contador = 3; lliphiphi promedio = 3.14; qillqa saludo = \"kamisaraki\"; chuymani activo = cheka;","title":"Tipos y variables"},{"location":"language/#condicionales","text":"si (contador > 0) { willt\u2019a\u00f1a(saludo); } sino { willt\u2019a\u00f1a(\"janiwa\"); }","title":"Condicionales"},{"location":"language/#bucles","text":"para i en range(0, 3) { willt\u2019a\u00f1a(i); } mientras (contador > 0) { contador = contador - 1; }","title":"Bucles"},{"location":"language/#funciones","text":"lur\u00e4wi inc(n) { kutiyana n + 1; } willt\u2019a\u00f1a(inc(5));","title":"Funciones"},{"location":"language/#modulos","text":"apu \"modules/aritmetica\"; willt\u2019a\u00f1a(\"suma: \" + suma(3, 4)); Los m\u00f3dulos se resuelven desde el directorio del archivo principal, desde una carpeta modules/ y desde rutas adicionales definidas en la variable de entorno AYM_PATH .","title":"M\u00f3dulos"},{"location":"language/#comentarios","text":"# comentario estilo aym // comentario estilo C /* bloque de comentario */ Anterior: Visi\u00f3n general | Siguiente: Gu\u00eda de caracter\u00edsticas","title":"Comentarios"},{"location":"overview/","text":"Visi\u00f3n general del lenguaje \u00b6 AymaraLang ( aym ) es un lenguaje de programaci\u00f3n moderno basado en la lengua originaria aymara. Su objetivo es facilitar el aprendizaje y la creaci\u00f3n de software sin sacrificar conceptos de ingenier\u00eda de compiladores. Identidad del lenguaje \u00b6 Elemento Valor Nombre del lenguaje aym Compilador aymc Extensi\u00f3n fuente .aym Ejecutable final .ayn Inspiraci\u00f3n Sintaxis con bloques indentados y palabras clave en aymara; backend en C++ Paradigmas Imperativo, orientado a objetos Tipado Est\u00e1tico, fuerte Principios de dise\u00f1o \u00b6 Cercan\u00eda cultural: palabras clave en aymara y ejemplos contextualizados. Ense\u00f1anza progresiva: sintaxis clara, cercana a lenguajes modernos. Compilaci\u00f3n nativa: salida a ejecutables sin dependencias externas. Portabilidad: soporte para Linux, Windows y macOS. Sintaxis del lenguaje \u00b6 Los bloques de c\u00f3digo se definen mediante : y niveles de sangr\u00eda. Todas las palabras clave y estructuras de control utilizan vocabulario aymara. jaqichawi act\u00faa como punto de entrada del programa. Los comentarios se introducen con # (y tambi\u00e9n se admite // ). Objetivos del proyecto \u00b6 Crear un lenguaje expresivo utilizando aymara como idioma principal. Implementar un compilador aut\u00f3nomo y multiplataforma sin dependencias externas. Promover la ense\u00f1anza de programaci\u00f3n en comunidades originarias. Servir como base cultural y t\u00e9cnica para proyectos educativos y ling\u00fc\u00edsticos. Anterior: Inicio | Siguiente: Primeros pasos","title":"Visi\u00f3n General"},{"location":"overview/#vision-general-del-lenguaje","text":"AymaraLang ( aym ) es un lenguaje de programaci\u00f3n moderno basado en la lengua originaria aymara. Su objetivo es facilitar el aprendizaje y la creaci\u00f3n de software sin sacrificar conceptos de ingenier\u00eda de compiladores.","title":"Visi\u00f3n general del lenguaje"},{"location":"overview/#identidad-del-lenguaje","text":"Elemento Valor Nombre del lenguaje aym Compilador aymc Extensi\u00f3n fuente .aym Ejecutable final .ayn Inspiraci\u00f3n Sintaxis con bloques indentados y palabras clave en aymara; backend en C++ Paradigmas Imperativo, orientado a objetos Tipado Est\u00e1tico, fuerte","title":"Identidad del lenguaje"},{"location":"overview/#principios-de-diseno","text":"Cercan\u00eda cultural: palabras clave en aymara y ejemplos contextualizados. Ense\u00f1anza progresiva: sintaxis clara, cercana a lenguajes modernos. Compilaci\u00f3n nativa: salida a ejecutables sin dependencias externas. Portabilidad: soporte para Linux, Windows y macOS.","title":"Principios de dise\u00f1o"},{"location":"overview/#sintaxis-del-lenguaje","text":"Los bloques de c\u00f3digo se definen mediante : y niveles de sangr\u00eda. Todas las palabras clave y estructuras de control utilizan vocabulario aymara. jaqichawi act\u00faa como punto de entrada del programa. Los comentarios se introducen con # (y tambi\u00e9n se admite // ).","title":"Sintaxis del lenguaje"},{"location":"overview/#objetivos-del-proyecto","text":"Crear un lenguaje expresivo utilizando aymara como idioma principal. Implementar un compilador aut\u00f3nomo y multiplataforma sin dependencias externas. Promover la ense\u00f1anza de programaci\u00f3n en comunidades originarias. Servir como base cultural y t\u00e9cnica para proyectos educativos y ling\u00fc\u00edsticos. Anterior: Inicio | Siguiente: Primeros pasos","title":"Objetivos del proyecto"},{"location":"project/","text":"Gu\u00eda del proyecto \u00b6 Tecnolog\u00edas y herramientas \u00b6 Lenguaje: C++17 Arquitectura objetivo: x86_64 Linux/Windows Assembler: NASM Linker: GNU LD / GCC (MinGW) Sistema de construcci\u00f3n: Make (Linux) / build.bat (Windows) IDE recomendados: CLion, VSCode, Vim Control de versiones: Git + GitHub Tests: make test Extensi\u00f3n para Visual Studio Code \u00b6 La extensi\u00f3n b\u00e1sica para resaltado de sintaxis vive en vscode-extension/ . Para empaquetar un .vsix , sigue las instrucciones en vscode-extension/README.md . Documentaci\u00f3n \u00b6 El sitio de documentaci\u00f3n est\u00e1 gestionado con MkDocs y vive en docs/ . Para levantarlo en local: pip install mkdocs mkdocs serve Estructura del repositorio \u00b6 /aym/ \u251c\u2500\u2500 compiler/ # C\u00f3digo fuente de 'aymc' \u2502 \u251c\u2500\u2500 lexer/ # Analizador l\u00e9xico \u2502 \u251c\u2500\u2500 parser/ # Analizador sint\u00e1ctico \u2502 \u251c\u2500\u2500 ast/ # Representaci\u00f3n del AST \u2502 \u251c\u2500\u2500 codegen/ # Generador de c\u00f3digo \u2502 \u2514\u2500\u2500 utils/ # Utilidades comunes \u251c\u2500\u2500 runtime/ # Biblioteca est\u00e1ndar m\u00ednima \u251c\u2500\u2500 samples/ # Ejemplos en .aym (basics/, control_flow/, functions/, data/) \u251c\u2500\u2500 tests/ # Tests automatizados \u251c\u2500\u2500 docs/ # Documentaci\u00f3n t\u00e9cnica (MkDocs) \u251c\u2500\u2500 build/ # Archivos generados \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 README.md Cronograma de desarrollo \u00b6 Semana Hito 1 Dise\u00f1o completo del lenguaje y gram\u00e1tica 2-3 Implementaci\u00f3n de Lexer y Parser 4 Construcci\u00f3n del AST y sistema de tipos 5-6 Generaci\u00f3n de c\u00f3digo + ensamblado inicial 7-8 Soporte para clases, ciclos y condiciones 9-10 Manejador de errores y mejoras de CLI 11 Librer\u00eda est\u00e1ndar m\u00ednima ( runtime/ ) 12 Documentaci\u00f3n, empaquetado y publicaci\u00f3n Licencia \u00b6 Este proyecto se distribuye bajo la licencia MIT . Contribuciones \u00b6 Este proyecto es abierto a toda colaboraci\u00f3n. Nos interesa especialmente: Hablantes nativos de aymara Desarrolladores C++ con experiencia en compiladores Educadores y promotores de software libre \u2728 \u00a1\u00danete al desarrollo y forma parte del cambio tecnol\u00f3gico-cultural! Anterior: Instaladores","title":"Gu\u00eda del proyecto"},{"location":"project/#guia-del-proyecto","text":"","title":"Gu\u00eda del proyecto"},{"location":"project/#tecnologias-y-herramientas","text":"Lenguaje: C++17 Arquitectura objetivo: x86_64 Linux/Windows Assembler: NASM Linker: GNU LD / GCC (MinGW) Sistema de construcci\u00f3n: Make (Linux) / build.bat (Windows) IDE recomendados: CLion, VSCode, Vim Control de versiones: Git + GitHub Tests: make test","title":"Tecnolog\u00edas y herramientas"},{"location":"project/#extension-para-visual-studio-code","text":"La extensi\u00f3n b\u00e1sica para resaltado de sintaxis vive en vscode-extension/ . Para empaquetar un .vsix , sigue las instrucciones en vscode-extension/README.md .","title":"Extensi\u00f3n para Visual Studio Code"},{"location":"project/#documentacion","text":"El sitio de documentaci\u00f3n est\u00e1 gestionado con MkDocs y vive en docs/ . Para levantarlo en local: pip install mkdocs mkdocs serve","title":"Documentaci\u00f3n"},{"location":"project/#estructura-del-repositorio","text":"/aym/ \u251c\u2500\u2500 compiler/ # C\u00f3digo fuente de 'aymc' \u2502 \u251c\u2500\u2500 lexer/ # Analizador l\u00e9xico \u2502 \u251c\u2500\u2500 parser/ # Analizador sint\u00e1ctico \u2502 \u251c\u2500\u2500 ast/ # Representaci\u00f3n del AST \u2502 \u251c\u2500\u2500 codegen/ # Generador de c\u00f3digo \u2502 \u2514\u2500\u2500 utils/ # Utilidades comunes \u251c\u2500\u2500 runtime/ # Biblioteca est\u00e1ndar m\u00ednima \u251c\u2500\u2500 samples/ # Ejemplos en .aym (basics/, control_flow/, functions/, data/) \u251c\u2500\u2500 tests/ # Tests automatizados \u251c\u2500\u2500 docs/ # Documentaci\u00f3n t\u00e9cnica (MkDocs) \u251c\u2500\u2500 build/ # Archivos generados \u251c\u2500\u2500 Makefile \u2514\u2500\u2500 README.md","title":"Estructura del repositorio"},{"location":"project/#cronograma-de-desarrollo","text":"Semana Hito 1 Dise\u00f1o completo del lenguaje y gram\u00e1tica 2-3 Implementaci\u00f3n de Lexer y Parser 4 Construcci\u00f3n del AST y sistema de tipos 5-6 Generaci\u00f3n de c\u00f3digo + ensamblado inicial 7-8 Soporte para clases, ciclos y condiciones 9-10 Manejador de errores y mejoras de CLI 11 Librer\u00eda est\u00e1ndar m\u00ednima ( runtime/ ) 12 Documentaci\u00f3n, empaquetado y publicaci\u00f3n","title":"Cronograma de desarrollo"},{"location":"project/#licencia","text":"Este proyecto se distribuye bajo la licencia MIT .","title":"Licencia"},{"location":"project/#contribuciones","text":"Este proyecto es abierto a toda colaboraci\u00f3n. Nos interesa especialmente: Hablantes nativos de aymara Desarrolladores C++ con experiencia en compiladores Educadores y promotores de software libre \u2728 \u00a1\u00danete al desarrollo y forma parte del cambio tecnol\u00f3gico-cultural! Anterior: Instaladores","title":"Contribuciones"},{"location":"systems_engineering/","text":"Sistemas de ingenier\u00eda \u00b6 Visi\u00f3n general \u00b6 La documentaci\u00f3n de sistemas de ingenier\u00eda para AymaraLang consolida el an\u00e1lisis y la gesti\u00f3n t\u00e9cnica del compilador, el runtime y sus herramientas asociadas. Este conjunto de documentos establece c\u00f3mo se define la arquitectura, los requisitos y los criterios de validaci\u00f3n para asegurar un producto mantenible y coherente. Alcance del an\u00e1lisis \u00b6 Arquitectura del sistema: organizaci\u00f3n modular del compilador, runtime y herramientas de apoyo. CONOPS: escenarios operativos y actores que interact\u00faan con la herramienta. Documento de control de interfaces: contratos y l\u00edmites entre componentes. Requisitos: requisitos funcionales y no funcionales. Gesti\u00f3n de riesgos: identificaci\u00f3n, mitigaci\u00f3n y seguimiento. Plan de gesti\u00f3n: gobernanza, planificaci\u00f3n y roles. Verificaci\u00f3n y validaci\u00f3n: criterios de aceptaci\u00f3n y evidencia de cumplimiento. Subm\u00f3dulos y documentos \u00b6 Arquitectura CONOPS Documento de control de interfaces Requisitos Gesti\u00f3n de riesgos Plan de gesti\u00f3n Verificaci\u00f3n y validaci\u00f3n Uso recomendado \u00b6 Revisar esta p\u00e1gina para comprender el marco de an\u00e1lisis general. Consultar cada documento espec\u00edfico para detalles t\u00e9cnicos y operativos. Mantener la consistencia entre requisitos, arquitectura y planes de validaci\u00f3n.","title":"Sistemas de ingenier\u00eda"},{"location":"systems_engineering/#sistemas-de-ingenieria","text":"","title":"Sistemas de ingenier\u00eda"},{"location":"systems_engineering/#vision-general","text":"La documentaci\u00f3n de sistemas de ingenier\u00eda para AymaraLang consolida el an\u00e1lisis y la gesti\u00f3n t\u00e9cnica del compilador, el runtime y sus herramientas asociadas. Este conjunto de documentos establece c\u00f3mo se define la arquitectura, los requisitos y los criterios de validaci\u00f3n para asegurar un producto mantenible y coherente.","title":"Visi\u00f3n general"},{"location":"systems_engineering/#alcance-del-analisis","text":"Arquitectura del sistema: organizaci\u00f3n modular del compilador, runtime y herramientas de apoyo. CONOPS: escenarios operativos y actores que interact\u00faan con la herramienta. Documento de control de interfaces: contratos y l\u00edmites entre componentes. Requisitos: requisitos funcionales y no funcionales. Gesti\u00f3n de riesgos: identificaci\u00f3n, mitigaci\u00f3n y seguimiento. Plan de gesti\u00f3n: gobernanza, planificaci\u00f3n y roles. Verificaci\u00f3n y validaci\u00f3n: criterios de aceptaci\u00f3n y evidencia de cumplimiento.","title":"Alcance del an\u00e1lisis"},{"location":"systems_engineering/#submodulos-y-documentos","text":"Arquitectura CONOPS Documento de control de interfaces Requisitos Gesti\u00f3n de riesgos Plan de gesti\u00f3n Verificaci\u00f3n y validaci\u00f3n","title":"Subm\u00f3dulos y documentos"},{"location":"systems_engineering/#uso-recomendado","text":"Revisar esta p\u00e1gina para comprender el marco de an\u00e1lisis general. Consultar cada documento espec\u00edfico para detalles t\u00e9cnicos y operativos. Mantener la consistencia entre requisitos, arquitectura y planes de validaci\u00f3n.","title":"Uso recomendado"},{"location":"systems_engineering/architecture/","text":"Descripci\u00f3n de Arquitectura del Sistema \u00b6 1. Visi\u00f3n general \u00b6 AymaraLang est\u00e1 compuesto por un compilador modular ( aymc ), un runtime m\u00ednimo y herramientas de apoyo. La arquitectura sigue el flujo cl\u00e1sico de compiladores con m\u00f3dulos desacoplados. 2. Arquitectura funcional \u00b6 M\u00f3dulo Responsabilidad Entradas Salidas Lexer Tokenizaci\u00f3n de c\u00f3digo fuente .aym Tokens Parser Construcci\u00f3n de AST Tokens AST Semantic An\u00e1lisis sem\u00e1ntico y tipos AST AST validado + s\u00edmbolos Codegen Generaci\u00f3n de NASM/LLVM AST validado .asm / .ll Linker Ensamblado/enlace .asm Binario 3. Arquitectura f\u00edsica (deployment) \u00b6 Entorno local: Linux/Windows. Dependencias: NASM, GCC/LD o MinGW, compilador C++17. Artefactos: .asm , .ll , binario nativo, logs de error. 4. Interfaces clave \u00b6 CLI: aymc [opciones] archivo.aym . Sistema de archivos: lectura de fuentes, escritura de artefactos. Runtime: funciones b\u00e1sicas de E/S utilizadas por el ejecutable. 5. Datos e informaci\u00f3n \u00b6 Tokens: tipo, texto, l\u00ednea y columna. AST: nodos de expresiones y sentencias. S\u00edmbolos: tablas de alcance para variables y funciones. 6. Restricciones de dise\u00f1o \u00b6 C++17 como est\u00e1ndar base. Codegen x86_64 (NASM) como backend principal. LLVM como backend experimental.","title":"Arquitectura de Sistemas"},{"location":"systems_engineering/architecture/#descripcion-de-arquitectura-del-sistema","text":"","title":"Descripci\u00f3n de Arquitectura del Sistema"},{"location":"systems_engineering/architecture/#1-vision-general","text":"AymaraLang est\u00e1 compuesto por un compilador modular ( aymc ), un runtime m\u00ednimo y herramientas de apoyo. La arquitectura sigue el flujo cl\u00e1sico de compiladores con m\u00f3dulos desacoplados.","title":"1. Visi\u00f3n general"},{"location":"systems_engineering/architecture/#2-arquitectura-funcional","text":"M\u00f3dulo Responsabilidad Entradas Salidas Lexer Tokenizaci\u00f3n de c\u00f3digo fuente .aym Tokens Parser Construcci\u00f3n de AST Tokens AST Semantic An\u00e1lisis sem\u00e1ntico y tipos AST AST validado + s\u00edmbolos Codegen Generaci\u00f3n de NASM/LLVM AST validado .asm / .ll Linker Ensamblado/enlace .asm Binario","title":"2. Arquitectura funcional"},{"location":"systems_engineering/architecture/#3-arquitectura-fisica-deployment","text":"Entorno local: Linux/Windows. Dependencias: NASM, GCC/LD o MinGW, compilador C++17. Artefactos: .asm , .ll , binario nativo, logs de error.","title":"3. Arquitectura f\u00edsica (deployment)"},{"location":"systems_engineering/architecture/#4-interfaces-clave","text":"CLI: aymc [opciones] archivo.aym . Sistema de archivos: lectura de fuentes, escritura de artefactos. Runtime: funciones b\u00e1sicas de E/S utilizadas por el ejecutable.","title":"4. Interfaces clave"},{"location":"systems_engineering/architecture/#5-datos-e-informacion","text":"Tokens: tipo, texto, l\u00ednea y columna. AST: nodos de expresiones y sentencias. S\u00edmbolos: tablas de alcance para variables y funciones.","title":"5. Datos e informaci\u00f3n"},{"location":"systems_engineering/architecture/#6-restricciones-de-diseno","text":"C++17 como est\u00e1ndar base. Codegen x86_64 (NASM) como backend principal. LLVM como backend experimental.","title":"6. Restricciones de dise\u00f1o"},{"location":"systems_engineering/conops/","text":"Concepto de Operaciones (ConOps) \u00b6 1. Prop\u00f3sito \u00b6 Describir c\u00f3mo los usuarios interact\u00faan con AymaraLang y su compilador aymc en escenarios reales, incluyendo flujos operativos, roles y restricciones. 2. Escenarios operativos \u00b6 2.1 Uso educativo en aula \u00b6 Docente distribuye ejemplos .aym . Estudiantes editan el c\u00f3digo en un editor de texto. Ejecutan aymc para compilar y correr los binarios. Se analiza salida para reforzar conceptos de programaci\u00f3n. 2.2 Uso comunitario y cultural \u00b6 Creaci\u00f3n de materiales educativos en aymara. Publicaci\u00f3n de ejemplos y ejercicios. Ejecuci\u00f3n en equipos modestos sin depender de conexi\u00f3n a internet. 3. Actores y responsabilidades \u00b6 Actor Responsabilidad Usuario final Escribir y ejecutar programas .aym Docente Dise\u00f1ar ejercicios y guiar el aprendizaje Desarrollador del compilador Mantener el compilador y documentaci\u00f3n 4. Supuestos \u00b6 El entorno cuenta con compilador C++ y herramientas de ensamblado/enlace. El usuario dispone de acceso de lectura/escritura al sistema de archivos. 5. Limitaciones operativas \u00b6 El backend LLVM es opcional y puede no estar disponible. Soporte limitado a x86_64 en la generaci\u00f3n nativa. 6. Criterios de \u00e9xito operacional \u00b6 Compilaci\u00f3n exitosa en menos de 2 segundos para ejemplos educativos. Ejecuci\u00f3n consistente en Windows y Linux. Mensajes de error comprensibles para estudiantes.","title":"CONOPS"},{"location":"systems_engineering/conops/#concepto-de-operaciones-conops","text":"","title":"Concepto de Operaciones (ConOps)"},{"location":"systems_engineering/conops/#1-proposito","text":"Describir c\u00f3mo los usuarios interact\u00faan con AymaraLang y su compilador aymc en escenarios reales, incluyendo flujos operativos, roles y restricciones.","title":"1. Prop\u00f3sito"},{"location":"systems_engineering/conops/#2-escenarios-operativos","text":"","title":"2. Escenarios operativos"},{"location":"systems_engineering/conops/#21-uso-educativo-en-aula","text":"Docente distribuye ejemplos .aym . Estudiantes editan el c\u00f3digo en un editor de texto. Ejecutan aymc para compilar y correr los binarios. Se analiza salida para reforzar conceptos de programaci\u00f3n.","title":"2.1 Uso educativo en aula"},{"location":"systems_engineering/conops/#22-uso-comunitario-y-cultural","text":"Creaci\u00f3n de materiales educativos en aymara. Publicaci\u00f3n de ejemplos y ejercicios. Ejecuci\u00f3n en equipos modestos sin depender de conexi\u00f3n a internet.","title":"2.2 Uso comunitario y cultural"},{"location":"systems_engineering/conops/#3-actores-y-responsabilidades","text":"Actor Responsabilidad Usuario final Escribir y ejecutar programas .aym Docente Dise\u00f1ar ejercicios y guiar el aprendizaje Desarrollador del compilador Mantener el compilador y documentaci\u00f3n","title":"3. Actores y responsabilidades"},{"location":"systems_engineering/conops/#4-supuestos","text":"El entorno cuenta con compilador C++ y herramientas de ensamblado/enlace. El usuario dispone de acceso de lectura/escritura al sistema de archivos.","title":"4. Supuestos"},{"location":"systems_engineering/conops/#5-limitaciones-operativas","text":"El backend LLVM es opcional y puede no estar disponible. Soporte limitado a x86_64 en la generaci\u00f3n nativa.","title":"5. Limitaciones operativas"},{"location":"systems_engineering/conops/#6-criterios-de-exito-operacional","text":"Compilaci\u00f3n exitosa en menos de 2 segundos para ejemplos educativos. Ejecuci\u00f3n consistente en Windows y Linux. Mensajes de error comprensibles para estudiantes.","title":"6. Criterios de \u00e9xito operacional"},{"location":"systems_engineering/interface_control_document/","text":"Documento de Control de Interfaces (ICD) \u00b6 1. Prop\u00f3sito \u00b6 Definir las interfaces principales del sistema AymaraLang y sus contratos de uso. 2. Interfaces externas \u00b6 2.1 CLI del compilador \u00b6 Comando: aymc [opciones] archivo.aym ... Opciones principales: --debug , --dump-ast , --seed , --llvm , --windows , --linux , -o . 2.2 Sistema de archivos \u00b6 Entradas: archivos .aym . Salidas: .asm , .ll y binario nativo. 2.3 Runtime \u00b6 Interfaz: llamadas a funciones integradas ( willt\u2019a\u00f1a , input , matem\u00e1ticas, arreglos). 3. Interfaces internas \u00b6 Interfaz Descripci\u00f3n Lexer \u2192 Parser Tokens con tipo/lexema/posici\u00f3n Parser \u2192 Semantic AST de nodos Expr / Stmt Semantic \u2192 Codegen AST validado + s\u00edmbolos Codegen \u2192 Linker .asm o .ll 4. Reglas de interoperabilidad \u00b6 El parser debe consumir tokens bien formados del lexer. El codegen solo opera sobre AST validado. El runtime debe mantener compatibilidad con el ABI usado por codegen.","title":"Control de Interfaces (ICD)"},{"location":"systems_engineering/interface_control_document/#documento-de-control-de-interfaces-icd","text":"","title":"Documento de Control de Interfaces (ICD)"},{"location":"systems_engineering/interface_control_document/#1-proposito","text":"Definir las interfaces principales del sistema AymaraLang y sus contratos de uso.","title":"1. Prop\u00f3sito"},{"location":"systems_engineering/interface_control_document/#2-interfaces-externas","text":"","title":"2. Interfaces externas"},{"location":"systems_engineering/interface_control_document/#21-cli-del-compilador","text":"Comando: aymc [opciones] archivo.aym ... Opciones principales: --debug , --dump-ast , --seed , --llvm , --windows , --linux , -o .","title":"2.1 CLI del compilador"},{"location":"systems_engineering/interface_control_document/#22-sistema-de-archivos","text":"Entradas: archivos .aym . Salidas: .asm , .ll y binario nativo.","title":"2.2 Sistema de archivos"},{"location":"systems_engineering/interface_control_document/#23-runtime","text":"Interfaz: llamadas a funciones integradas ( willt\u2019a\u00f1a , input , matem\u00e1ticas, arreglos).","title":"2.3 Runtime"},{"location":"systems_engineering/interface_control_document/#3-interfaces-internas","text":"Interfaz Descripci\u00f3n Lexer \u2192 Parser Tokens con tipo/lexema/posici\u00f3n Parser \u2192 Semantic AST de nodos Expr / Stmt Semantic \u2192 Codegen AST validado + s\u00edmbolos Codegen \u2192 Linker .asm o .ll","title":"3. Interfaces internas"},{"location":"systems_engineering/interface_control_document/#4-reglas-de-interoperabilidad","text":"El parser debe consumir tokens bien formados del lexer. El codegen solo opera sobre AST validado. El runtime debe mantener compatibilidad con el ABI usado por codegen.","title":"4. Reglas de interoperabilidad"},{"location":"systems_engineering/requirements/","text":"Especificaci\u00f3n de requisitos y documentaci\u00f3n de ingenier\u00eda de sistemas (SEBOK/INCOSE) \u00b6 Basado en pr\u00e1cticas de SEBOK e INCOSE para captura de requisitos, definici\u00f3n de sistema y verificaci\u00f3n. 1. Prop\u00f3sito \u00b6 Definir los requisitos del sistema AymaraLang (aym) y su compilador aymc , as\u00ed como el contexto operativo, stakeholders, interfaces, restricciones y criterios de verificaci\u00f3n, utilizando una estructura compatible con SEBOK/INCOSE. 2. Alcance del sistema \u00b6 Sistema bajo estudio (SoS): - Compilador aymc (C++17) y backend de generaci\u00f3n de ejecutables. - Lenguaje AymaraLang (archivos fuente .aym ). - Runtime m\u00ednimo para E/S y utilidades est\u00e1ndar. Fuera de alcance: - IDEs o extensiones de editor. - Librer\u00edas est\u00e1ndar externas adicionales. - Integraci\u00f3n con servicios en la nube. 3. Stakeholders y necesidades \u00b6 Stakeholder Necesidad/objetivo Prioridad Docentes y estudiantes Lenguaje accesible y representativo del aymara Alta Desarrolladores del compilador Arquitectura modular y mantenible Alta Usuarios finales Ejecutables nativos r\u00e1pidos Alta Comunidad cultural Preservaci\u00f3n ling\u00fc\u00edstica y material educativo Media 4. Concepto de operaciones (ConOps) \u00b6 El usuario escribe c\u00f3digo .aym con sintaxis en aymara. Ejecuta aymc para compilar a un binario nativo ( .ayn o .exe ). El compilador realiza: lexer \u2192 parser \u2192 AST \u2192 an\u00e1lisis sem\u00e1ntico \u2192 codegen \u2192 ensamblado/enlace. El ejecutable resultante corre en el sistema objetivo. 5. Contexto del sistema y l\u00edmites \u00b6 Entorno operativo: - Sistemas Linux/Windows (con soporte de toolchain para NASM/LD/GCC o MinGW). - Dependencias de compilaci\u00f3n: g++ / clang++ , nasm , gcc/ld . Interfaces externas clave: - CLI del compilador ( aymc ). - Sistema de archivos (lectura .aym , escritura .asm / .ll y binarios). - Backend LLVM (opcional, activado con --llvm ). 6. Arquitectura funcional (resumen) \u00b6 Funci\u00f3n Entrada Salida An\u00e1lisis l\u00e9xico C\u00f3digo .aym Tokens An\u00e1lisis sint\u00e1ctico Tokens AST An\u00e1lisis sem\u00e1ntico AST AST validado + s\u00edmbolos Generaci\u00f3n de c\u00f3digo AST validado .asm / .ll Ensamblado/enlace .asm Binario nativo 7. Requisitos del sistema \u00b6 7.1 Requisitos funcionales (FR) \u00b6 FR-01 El sistema debe aceptar uno o m\u00e1s archivos .aym como entrada por CLI. FR-02 El sistema debe tokenizar el c\u00f3digo fuente y producir tokens conforme a palabras clave y s\u00edmbolos del lenguaje. FR-03 El sistema debe generar un AST v\u00e1lido mediante an\u00e1lisis sint\u00e1ctico LL. FR-04 El sistema debe validar sem\u00e1ntica (tipado, s\u00edmbolos y llamadas) antes de generar c\u00f3digo. FR-05 El sistema debe generar ensamblador NASM x86_64 y enlazar un ejecutable nativo. FR-06 El sistema debe permitir seleccionar objetivo Linux o Windows desde la CLI. FR-07 El sistema debe admitir un backend LLVM experimental que genere .ll . FR-08 El sistema debe soportar m\u00f3dulos importados desde archivos externos. FR-09 El sistema debe incluir funciones integradas (E/S, matem\u00e1ticas, arreglos, aleatoriedad). 7.2 Requisitos no funcionales (NFR) \u00b6 NFR-01 El compilador debe ejecutarse en Linux y Windows con toolchain est\u00e1ndar. NFR-02 El tiempo de compilaci\u00f3n debe ser adecuado para programas educativos (<= 2s para archivos peque\u00f1os en equipos de clase). NFR-03 El sistema debe proporcionar mensajes de error legibles para errores l\u00e9xicos, sint\u00e1cticos y sem\u00e1nticos. NFR-04 El c\u00f3digo debe mantener una estructura modular (lexer/parser/ast/semantic/codegen). NFR-05 El proyecto debe compilarse con C++17. 7.3 Requisitos de interfaz (IR) \u00b6 IR-01 CLI principal: aymc [opciones] archivo.aym ... . IR-02 Opciones: --debug , --dump-ast , --seed , --llvm , --windows , --linux , -o . IR-03 Archivos de salida: .asm (NASM), .ll (LLVM), y ejecutable nativo. 8. Restricciones y supuestos \u00b6 Se requiere toolchain (NASM y GCC/LD o MinGW) disponible en PATH. El backend LLVM es opcional y depende de compilaci\u00f3n con soporte. El lenguaje est\u00e1 orientado a tipado est\u00e1tico y a constructs definidos en la gram\u00e1tica. 9. Verificaci\u00f3n y validaci\u00f3n (V&V) \u00b6 Requisito M\u00e9todo Evidencia esperada FR-01 Inspecci\u00f3n/Prueba aymc archivo.aym compila sin errores FR-05 Prueba Se genera .asm y binario ejecutable FR-07 Prueba Se genera archivo .ll NFR-05 Inspecci\u00f3n Uso de -std=c++17 en build 10. Trazabilidad (resumen) \u00b6 Requisito Elemento de dise\u00f1o Evidencia t\u00e9cnica FR-01 CLI main.cpp Parsing de argumentos FR-02 lexer/ Tokenizaci\u00f3n FR-03 parser/ Construcci\u00f3n de AST FR-04 semantic/ An\u00e1lisis de tipos FR-05 codegen/ Generaci\u00f3n NASM FR-07 codegen/llvm/ LLVM IR FR-08 module_resolver Resoluci\u00f3n de m\u00f3dulos FR-09 builtins/ Funciones integradas 11. Riesgos t\u00e9cnicos (alto nivel) \u00b6 Dependencia de toolchain externo para ensamblado/enlace. Backend LLVM incompleto o experimental. Compatibilidad limitada con arquitecturas distintas de x86_64. 12. Glosario \u00b6 AST: \u00c1rbol de Sintaxis Abstracta. V&V: Verificaci\u00f3n y validaci\u00f3n. ConOps: Concepto de operaciones.","title":"Requisitos"},{"location":"systems_engineering/requirements/#especificacion-de-requisitos-y-documentacion-de-ingenieria-de-sistemas-sebokincose","text":"Basado en pr\u00e1cticas de SEBOK e INCOSE para captura de requisitos, definici\u00f3n de sistema y verificaci\u00f3n.","title":"Especificaci\u00f3n de requisitos y documentaci\u00f3n de ingenier\u00eda de sistemas (SEBOK/INCOSE)"},{"location":"systems_engineering/requirements/#1-proposito","text":"Definir los requisitos del sistema AymaraLang (aym) y su compilador aymc , as\u00ed como el contexto operativo, stakeholders, interfaces, restricciones y criterios de verificaci\u00f3n, utilizando una estructura compatible con SEBOK/INCOSE.","title":"1. Prop\u00f3sito"},{"location":"systems_engineering/requirements/#2-alcance-del-sistema","text":"Sistema bajo estudio (SoS): - Compilador aymc (C++17) y backend de generaci\u00f3n de ejecutables. - Lenguaje AymaraLang (archivos fuente .aym ). - Runtime m\u00ednimo para E/S y utilidades est\u00e1ndar. Fuera de alcance: - IDEs o extensiones de editor. - Librer\u00edas est\u00e1ndar externas adicionales. - Integraci\u00f3n con servicios en la nube.","title":"2. Alcance del sistema"},{"location":"systems_engineering/requirements/#3-stakeholders-y-necesidades","text":"Stakeholder Necesidad/objetivo Prioridad Docentes y estudiantes Lenguaje accesible y representativo del aymara Alta Desarrolladores del compilador Arquitectura modular y mantenible Alta Usuarios finales Ejecutables nativos r\u00e1pidos Alta Comunidad cultural Preservaci\u00f3n ling\u00fc\u00edstica y material educativo Media","title":"3. Stakeholders y necesidades"},{"location":"systems_engineering/requirements/#4-concepto-de-operaciones-conops","text":"El usuario escribe c\u00f3digo .aym con sintaxis en aymara. Ejecuta aymc para compilar a un binario nativo ( .ayn o .exe ). El compilador realiza: lexer \u2192 parser \u2192 AST \u2192 an\u00e1lisis sem\u00e1ntico \u2192 codegen \u2192 ensamblado/enlace. El ejecutable resultante corre en el sistema objetivo.","title":"4. Concepto de operaciones (ConOps)"},{"location":"systems_engineering/requirements/#5-contexto-del-sistema-y-limites","text":"Entorno operativo: - Sistemas Linux/Windows (con soporte de toolchain para NASM/LD/GCC o MinGW). - Dependencias de compilaci\u00f3n: g++ / clang++ , nasm , gcc/ld . Interfaces externas clave: - CLI del compilador ( aymc ). - Sistema de archivos (lectura .aym , escritura .asm / .ll y binarios). - Backend LLVM (opcional, activado con --llvm ).","title":"5. Contexto del sistema y l\u00edmites"},{"location":"systems_engineering/requirements/#6-arquitectura-funcional-resumen","text":"Funci\u00f3n Entrada Salida An\u00e1lisis l\u00e9xico C\u00f3digo .aym Tokens An\u00e1lisis sint\u00e1ctico Tokens AST An\u00e1lisis sem\u00e1ntico AST AST validado + s\u00edmbolos Generaci\u00f3n de c\u00f3digo AST validado .asm / .ll Ensamblado/enlace .asm Binario nativo","title":"6. Arquitectura funcional (resumen)"},{"location":"systems_engineering/requirements/#7-requisitos-del-sistema","text":"","title":"7. Requisitos del sistema"},{"location":"systems_engineering/requirements/#71-requisitos-funcionales-fr","text":"FR-01 El sistema debe aceptar uno o m\u00e1s archivos .aym como entrada por CLI. FR-02 El sistema debe tokenizar el c\u00f3digo fuente y producir tokens conforme a palabras clave y s\u00edmbolos del lenguaje. FR-03 El sistema debe generar un AST v\u00e1lido mediante an\u00e1lisis sint\u00e1ctico LL. FR-04 El sistema debe validar sem\u00e1ntica (tipado, s\u00edmbolos y llamadas) antes de generar c\u00f3digo. FR-05 El sistema debe generar ensamblador NASM x86_64 y enlazar un ejecutable nativo. FR-06 El sistema debe permitir seleccionar objetivo Linux o Windows desde la CLI. FR-07 El sistema debe admitir un backend LLVM experimental que genere .ll . FR-08 El sistema debe soportar m\u00f3dulos importados desde archivos externos. FR-09 El sistema debe incluir funciones integradas (E/S, matem\u00e1ticas, arreglos, aleatoriedad).","title":"7.1 Requisitos funcionales (FR)"},{"location":"systems_engineering/requirements/#72-requisitos-no-funcionales-nfr","text":"NFR-01 El compilador debe ejecutarse en Linux y Windows con toolchain est\u00e1ndar. NFR-02 El tiempo de compilaci\u00f3n debe ser adecuado para programas educativos (<= 2s para archivos peque\u00f1os en equipos de clase). NFR-03 El sistema debe proporcionar mensajes de error legibles para errores l\u00e9xicos, sint\u00e1cticos y sem\u00e1nticos. NFR-04 El c\u00f3digo debe mantener una estructura modular (lexer/parser/ast/semantic/codegen). NFR-05 El proyecto debe compilarse con C++17.","title":"7.2 Requisitos no funcionales (NFR)"},{"location":"systems_engineering/requirements/#73-requisitos-de-interfaz-ir","text":"IR-01 CLI principal: aymc [opciones] archivo.aym ... . IR-02 Opciones: --debug , --dump-ast , --seed , --llvm , --windows , --linux , -o . IR-03 Archivos de salida: .asm (NASM), .ll (LLVM), y ejecutable nativo.","title":"7.3 Requisitos de interfaz (IR)"},{"location":"systems_engineering/requirements/#8-restricciones-y-supuestos","text":"Se requiere toolchain (NASM y GCC/LD o MinGW) disponible en PATH. El backend LLVM es opcional y depende de compilaci\u00f3n con soporte. El lenguaje est\u00e1 orientado a tipado est\u00e1tico y a constructs definidos en la gram\u00e1tica.","title":"8. Restricciones y supuestos"},{"location":"systems_engineering/requirements/#9-verificacion-y-validacion-vv","text":"Requisito M\u00e9todo Evidencia esperada FR-01 Inspecci\u00f3n/Prueba aymc archivo.aym compila sin errores FR-05 Prueba Se genera .asm y binario ejecutable FR-07 Prueba Se genera archivo .ll NFR-05 Inspecci\u00f3n Uso de -std=c++17 en build","title":"9. Verificaci\u00f3n y validaci\u00f3n (V&amp;V)"},{"location":"systems_engineering/requirements/#10-trazabilidad-resumen","text":"Requisito Elemento de dise\u00f1o Evidencia t\u00e9cnica FR-01 CLI main.cpp Parsing de argumentos FR-02 lexer/ Tokenizaci\u00f3n FR-03 parser/ Construcci\u00f3n de AST FR-04 semantic/ An\u00e1lisis de tipos FR-05 codegen/ Generaci\u00f3n NASM FR-07 codegen/llvm/ LLVM IR FR-08 module_resolver Resoluci\u00f3n de m\u00f3dulos FR-09 builtins/ Funciones integradas","title":"10. Trazabilidad (resumen)"},{"location":"systems_engineering/requirements/#11-riesgos-tecnicos-alto-nivel","text":"Dependencia de toolchain externo para ensamblado/enlace. Backend LLVM incompleto o experimental. Compatibilidad limitada con arquitecturas distintas de x86_64.","title":"11. Riesgos t\u00e9cnicos (alto nivel)"},{"location":"systems_engineering/requirements/#12-glosario","text":"AST: \u00c1rbol de Sintaxis Abstracta. V&V: Verificaci\u00f3n y validaci\u00f3n. ConOps: Concepto de operaciones.","title":"12. Glosario"},{"location":"systems_engineering/risk_management/","text":"Plan de Gesti\u00f3n de Riesgos \u00b6 1. Objetivo \u00b6 Identificar, evaluar y mitigar riesgos t\u00e9cnicos y de proyecto asociados al desarrollo y uso de AymaraLang. 2. Metodolog\u00eda \u00b6 Identificaci\u00f3n de riesgos. Evaluaci\u00f3n de probabilidad e impacto. Planes de mitigaci\u00f3n y contingencia. 3. Registro de riesgos \u00b6 ID Riesgo Probabilidad Impacto Mitigaci\u00f3n R-01 Dependencia de toolchain externo Media Alta Documentar dependencias y validar en CI R-02 Backend LLVM incompleto Media Media Mantener backend NASM como principal R-03 Compatibilidad limitada a x86_64 Alta Media Definir roadmap multi-arquitectura R-04 Curva de aprendizaje de sintaxis aymara Media Media Crear gu\u00edas y ejemplos accesibles R-05 Falta de recursos para pruebas en Windows Media Media Automatizar tests y usar runners multi-OS 4. Monitoreo \u00b6 Revisiones trimestrales del registro de riesgos. Seguimiento de issues en GitHub.","title":"Gesti\u00f3n de Riesgos"},{"location":"systems_engineering/risk_management/#plan-de-gestion-de-riesgos","text":"","title":"Plan de Gesti\u00f3n de Riesgos"},{"location":"systems_engineering/risk_management/#1-objetivo","text":"Identificar, evaluar y mitigar riesgos t\u00e9cnicos y de proyecto asociados al desarrollo y uso de AymaraLang.","title":"1. Objetivo"},{"location":"systems_engineering/risk_management/#2-metodologia","text":"Identificaci\u00f3n de riesgos. Evaluaci\u00f3n de probabilidad e impacto. Planes de mitigaci\u00f3n y contingencia.","title":"2. Metodolog\u00eda"},{"location":"systems_engineering/risk_management/#3-registro-de-riesgos","text":"ID Riesgo Probabilidad Impacto Mitigaci\u00f3n R-01 Dependencia de toolchain externo Media Alta Documentar dependencias y validar en CI R-02 Backend LLVM incompleto Media Media Mantener backend NASM como principal R-03 Compatibilidad limitada a x86_64 Alta Media Definir roadmap multi-arquitectura R-04 Curva de aprendizaje de sintaxis aymara Media Media Crear gu\u00edas y ejemplos accesibles R-05 Falta de recursos para pruebas en Windows Media Media Automatizar tests y usar runners multi-OS","title":"3. Registro de riesgos"},{"location":"systems_engineering/risk_management/#4-monitoreo","text":"Revisiones trimestrales del registro de riesgos. Seguimiento de issues en GitHub.","title":"4. Monitoreo"},{"location":"systems_engineering/systems_engineering_management_plan/","text":"Plan de Gesti\u00f3n de Ingenier\u00eda de Sistemas (SEMP) \u00b6 1. Objetivo \u00b6 Establecer la estrategia, procesos y entregables de ingenier\u00eda de sistemas para AymaraLang. 2. Alcance \u00b6 Definici\u00f3n de requisitos (SRD). Arquitectura y dise\u00f1o. Verificaci\u00f3n y validaci\u00f3n. Gesti\u00f3n de configuraci\u00f3n y riesgos. 3. Procesos principales \u00b6 Proceso Actividades Requisitos Captura, an\u00e1lisis, trazabilidad Arquitectura Definici\u00f3n modular y interfaces Implementaci\u00f3n Desarrollo iterativo en C++17 V&V Pruebas, inspecciones, demostraciones Gesti\u00f3n de cambios Git + revisi\u00f3n por PR 4. Entregables \u00b6 Especificaci\u00f3n de requisitos. ConOps. Documento de arquitectura. ICD. Plan de V&V. Registro de riesgos. 5. Gesti\u00f3n de configuraci\u00f3n \u00b6 Repositorio Git como fuente \u00fanica. Versionado sem\u00e1ntico para releases. Control de cambios v\u00eda PR. 6. M\u00e9tricas \u00b6 Porcentaje de requisitos verificados. Cobertura de pruebas en tests/ . Tiempo promedio de compilaci\u00f3n.","title":"Plan de Gesti\u00f3n (SEMP)"},{"location":"systems_engineering/systems_engineering_management_plan/#plan-de-gestion-de-ingenieria-de-sistemas-semp","text":"","title":"Plan de Gesti\u00f3n de Ingenier\u00eda de Sistemas (SEMP)"},{"location":"systems_engineering/systems_engineering_management_plan/#1-objetivo","text":"Establecer la estrategia, procesos y entregables de ingenier\u00eda de sistemas para AymaraLang.","title":"1. Objetivo"},{"location":"systems_engineering/systems_engineering_management_plan/#2-alcance","text":"Definici\u00f3n de requisitos (SRD). Arquitectura y dise\u00f1o. Verificaci\u00f3n y validaci\u00f3n. Gesti\u00f3n de configuraci\u00f3n y riesgos.","title":"2. Alcance"},{"location":"systems_engineering/systems_engineering_management_plan/#3-procesos-principales","text":"Proceso Actividades Requisitos Captura, an\u00e1lisis, trazabilidad Arquitectura Definici\u00f3n modular y interfaces Implementaci\u00f3n Desarrollo iterativo en C++17 V&V Pruebas, inspecciones, demostraciones Gesti\u00f3n de cambios Git + revisi\u00f3n por PR","title":"3. Procesos principales"},{"location":"systems_engineering/systems_engineering_management_plan/#4-entregables","text":"Especificaci\u00f3n de requisitos. ConOps. Documento de arquitectura. ICD. Plan de V&V. Registro de riesgos.","title":"4. Entregables"},{"location":"systems_engineering/systems_engineering_management_plan/#5-gestion-de-configuracion","text":"Repositorio Git como fuente \u00fanica. Versionado sem\u00e1ntico para releases. Control de cambios v\u00eda PR.","title":"5. Gesti\u00f3n de configuraci\u00f3n"},{"location":"systems_engineering/systems_engineering_management_plan/#6-metricas","text":"Porcentaje de requisitos verificados. Cobertura de pruebas en tests/ . Tiempo promedio de compilaci\u00f3n.","title":"6. M\u00e9tricas"},{"location":"systems_engineering/verification_validation_plan/","text":"Plan de Verificaci\u00f3n y Validaci\u00f3n (V&V) \u00b6 1. Objetivo \u00b6 Definir c\u00f3mo se verificar\u00e1 y validar\u00e1 AymaraLang y su compilador para asegurar cumplimiento de requisitos. 2. Alcance \u00b6 Compilador aymc (lexer, parser, semantic, codegen). Backend LLVM experimental. Runtime m\u00ednimo. 3. Estrategia de V&V \u00b6 Tipo Descripci\u00f3n Inspecci\u00f3n Revisi\u00f3n de c\u00f3digo y documentaci\u00f3n Prueba Ejecuci\u00f3n de casos de prueba automatizados An\u00e1lisis Comparaci\u00f3n de resultados esperados 4. Matriz de verificaci\u00f3n (resumen) \u00b6 Requisito M\u00e9todo Evidencia FR-01 Prueba Compila m\u00faltiples archivos .aym FR-05 Prueba Binario ejecuta ejemplos FR-07 Prueba Generaci\u00f3n de .ll NFR-03 Inspecci\u00f3n Mensajes de error legibles 5. Criterios de aceptaci\u00f3n \u00b6 Todos los ejemplos en samples/ deben compilar y ejecutarse. make test debe pasar sin errores (cuando el entorno lo permita). 6. Artefactos de evidencia \u00b6 Reportes de ejecuci\u00f3n de make test . Logs de compilaci\u00f3n y salida de ejemplos.","title":"Plan de Verificaci\u00f3n y Validaci\u00f3n (V&amp;V)"},{"location":"systems_engineering/verification_validation_plan/#plan-de-verificacion-y-validacion-vv","text":"","title":"Plan de Verificaci\u00f3n y Validaci\u00f3n (V&amp;V)"},{"location":"systems_engineering/verification_validation_plan/#1-objetivo","text":"Definir c\u00f3mo se verificar\u00e1 y validar\u00e1 AymaraLang y su compilador para asegurar cumplimiento de requisitos.","title":"1. Objetivo"},{"location":"systems_engineering/verification_validation_plan/#2-alcance","text":"Compilador aymc (lexer, parser, semantic, codegen). Backend LLVM experimental. Runtime m\u00ednimo.","title":"2. Alcance"},{"location":"systems_engineering/verification_validation_plan/#3-estrategia-de-vv","text":"Tipo Descripci\u00f3n Inspecci\u00f3n Revisi\u00f3n de c\u00f3digo y documentaci\u00f3n Prueba Ejecuci\u00f3n de casos de prueba automatizados An\u00e1lisis Comparaci\u00f3n de resultados esperados","title":"3. Estrategia de V&amp;V"},{"location":"systems_engineering/verification_validation_plan/#4-matriz-de-verificacion-resumen","text":"Requisito M\u00e9todo Evidencia FR-01 Prueba Compila m\u00faltiples archivos .aym FR-05 Prueba Binario ejecuta ejemplos FR-07 Prueba Generaci\u00f3n de .ll NFR-03 Inspecci\u00f3n Mensajes de error legibles","title":"4. Matriz de verificaci\u00f3n (resumen)"},{"location":"systems_engineering/verification_validation_plan/#5-criterios-de-aceptacion","text":"Todos los ejemplos en samples/ deben compilar y ejecutarse. make test debe pasar sin errores (cuando el entorno lo permita).","title":"5. Criterios de aceptaci\u00f3n"},{"location":"systems_engineering/verification_validation_plan/#6-artefactos-de-evidencia","text":"Reportes de ejecuci\u00f3n de make test . Logs de compilaci\u00f3n y salida de ejemplos.","title":"6. Artefactos de evidencia"}]}