{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AymaraLang \u2014 documentaci\u00f3n \u00b6 Bienvenido/a. Esta documentaci\u00f3n resume el lenguaje, el compilador y los materiales de investigaci\u00f3n del proyecto de forma concisa. Rutas principales \u00b6 Panorama del proyecto: Visi\u00f3n general , Compilaci\u00f3n e instalaci\u00f3n , CLI del compilador y Arquitectura . Lenguaje: Primeros pasos , Referencia r\u00e1pida , Manejo de errores y Gram\u00e1tica formal . Investigaci\u00f3n y teor\u00eda: Fundamentos matem\u00e1ticos y de compiladores . Ingenier\u00eda de sistemas (investigaci\u00f3n): documentos en docs/systems_engineering/ . Incluyen plan de gesti\u00f3n, requisitos, arquitectura y validaci\u00f3n. LaTeX/Overleaf: los insumos en docs/systems_engineering/overleaf/ son parte del material de investigaci\u00f3n y se mantienen vigentes. Sitio MkDocs \u00b6 pip install mkdocs mkdocs serve Luego abre http://127.0.0.1:8000 . Recursos visuales y f\u00f3rmulas \u00b6 La documentaci\u00f3n usa diagramas Mermaid y f\u00f3rmulas matem\u00e1ticas para reforzar la investigaci\u00f3n. Por ejemplo, el tiempo de an\u00e1lisis l\u00e9xico puede modelarse como \\(O(n)\\) respecto al tama\u00f1o de la entrada.","title":"Inicio"},{"location":"#aymaralang-documentacion","text":"Bienvenido/a. Esta documentaci\u00f3n resume el lenguaje, el compilador y los materiales de investigaci\u00f3n del proyecto de forma concisa.","title":"AymaraLang \u2014 documentaci\u00f3n"},{"location":"#rutas-principales","text":"Panorama del proyecto: Visi\u00f3n general , Compilaci\u00f3n e instalaci\u00f3n , CLI del compilador y Arquitectura . Lenguaje: Primeros pasos , Referencia r\u00e1pida , Manejo de errores y Gram\u00e1tica formal . Investigaci\u00f3n y teor\u00eda: Fundamentos matem\u00e1ticos y de compiladores . Ingenier\u00eda de sistemas (investigaci\u00f3n): documentos en docs/systems_engineering/ . Incluyen plan de gesti\u00f3n, requisitos, arquitectura y validaci\u00f3n. LaTeX/Overleaf: los insumos en docs/systems_engineering/overleaf/ son parte del material de investigaci\u00f3n y se mantienen vigentes.","title":"Rutas principales"},{"location":"#sitio-mkdocs","text":"pip install mkdocs mkdocs serve Luego abre http://127.0.0.1:8000 .","title":"Sitio MkDocs"},{"location":"#recursos-visuales-y-formulas","text":"La documentaci\u00f3n usa diagramas Mermaid y f\u00f3rmulas matem\u00e1ticas para reforzar la investigaci\u00f3n. Por ejemplo, el tiempo de an\u00e1lisis l\u00e9xico puede modelarse como \\(O(n)\\) respecto al tama\u00f1o de la entrada.","title":"Recursos visuales y f\u00f3rmulas"},{"location":"arquitectura/","text":"Arquitectura del compilador aymc \u00b6 Este documento resume los m\u00f3dulos principales y su flujo de compilaci\u00f3n. Vista general \u00b6 flowchart LR classDef front fill:#dbeafe,stroke:#1e40af,color:#000; classDef middle fill:#dcfce7,stroke:#166534,color:#000; classDef back fill:#fee2e2,stroke:#7f1d1d,color:#000; A[Fuente .aym] --> B[Lexer] B --> C[Parser] C --> D[AST] D --> E[Analisis semantico] E --> F[Codegen NASM] F --> G[Ensamblador + Linker] G --> H[Ejecutable nativo] E --> I[Codegen LLVM opcional] I --> J[IR LLVM .ll] class A,B,C,D front class E middle class F,G,H,I,J back M\u00f3dulos principales \u00b6 Lexer ( compiler/lexer ) : tokeniza el c\u00f3digo fuente. Parser ( compiler/parser ) : construye el AST y valida la sintaxis. AST ( compiler/ast ) : nodos de expresiones y sentencias. Sem\u00e1ntica ( compiler/semantic ) : tipos, s\u00edmbolos, clases y excepciones. Codegen ( compiler/codegen ) : genera NASM o LLVM IR. Runtime ( runtime/ ) : funciones base usadas por los binarios. Module resolver ( utils/module_resolver ) : carga apnaq y gestiona rutas. flowchart TB Lexer --> Parser Parser --> AST AST --> Semantica[Sem\u00e1ntica] Semantica --> Codegen Codegen --> Runtime Semantica --> Resolver[Module Resolver] Artefactos clave \u00b6 *.asm y *.o / *.obj para el backend NASM. *.ll para el backend LLVM (si est\u00e1 habilitado). Binario final nativo. Siguiente: Gu\u00eda del proyecto","title":"Arquitectura del compilador"},{"location":"arquitectura/#arquitectura-del-compilador-aymc","text":"Este documento resume los m\u00f3dulos principales y su flujo de compilaci\u00f3n.","title":"Arquitectura del compilador aymc"},{"location":"arquitectura/#vista-general","text":"flowchart LR classDef front fill:#dbeafe,stroke:#1e40af,color:#000; classDef middle fill:#dcfce7,stroke:#166534,color:#000; classDef back fill:#fee2e2,stroke:#7f1d1d,color:#000; A[Fuente .aym] --> B[Lexer] B --> C[Parser] C --> D[AST] D --> E[Analisis semantico] E --> F[Codegen NASM] F --> G[Ensamblador + Linker] G --> H[Ejecutable nativo] E --> I[Codegen LLVM opcional] I --> J[IR LLVM .ll] class A,B,C,D front class E middle class F,G,H,I,J back","title":"Vista general"},{"location":"arquitectura/#modulos-principales","text":"Lexer ( compiler/lexer ) : tokeniza el c\u00f3digo fuente. Parser ( compiler/parser ) : construye el AST y valida la sintaxis. AST ( compiler/ast ) : nodos de expresiones y sentencias. Sem\u00e1ntica ( compiler/semantic ) : tipos, s\u00edmbolos, clases y excepciones. Codegen ( compiler/codegen ) : genera NASM o LLVM IR. Runtime ( runtime/ ) : funciones base usadas por los binarios. Module resolver ( utils/module_resolver ) : carga apnaq y gestiona rutas. flowchart TB Lexer --> Parser Parser --> AST AST --> Semantica[Sem\u00e1ntica] Semantica --> Codegen Codegen --> Runtime Semantica --> Resolver[Module Resolver]","title":"M\u00f3dulos principales"},{"location":"arquitectura/#artefactos-clave","text":"*.asm y *.o / *.obj para el backend NASM. *.ll para el backend LLVM (si est\u00e1 habilitado). Binario final nativo. Siguiente: Gu\u00eda del proyecto","title":"Artefactos clave"},{"location":"aymaraLang/","text":"Referencia r\u00e1pida del lenguaje \u00b6 Esta p\u00e1gina resume lo esencial del lenguaje para consulta r\u00e1pida. Para la gram\u00e1tica formal revisa Gram\u00e1tica . Tipos \u00b6 jakh\u00fcwi (num\u00e9rico) aru (texto) chiqa (booleano) t'aqa / lista\u00f1a (listas) mapa (mapas) Literales \u00b6 Booleanos: chiqa / k'ari (legacy: utji / janiutji ). N\u00fameros: decimales, 0x (hex) y 0b (binario). Cadenas: comillas simples o dobles con escapes. Estructuras principales \u00b6 Condicionales: jisa / maysatxa Bucles: ukhakamaxa , taki Funciones: lurawi / kuttaya Clases: kasta , machaqa , aka , jila , jikxata , sapa , taqi , sapakasta , u\u00f1t'aya , chura , jilaaka Excepciones: yant'a\u00f1a , katja\u00f1a , tukuyawi , pantja M\u00f3dulos: apnaq Biblioteca est\u00e1ndar (built-ins) \u00b6 Entrada/Salida y utilidades \u00b6 qillqa , write , input , katu , sleep , random Conversi\u00f3n y longitud \u00b6 aru , jakh\u00fcwi , length , largo , suyu , suyut , suyum Arreglos (din\u00e1micos) \u00b6 array , array_get , array_set , array_free , array_length Texto \u00b6 ch'usa , jaljta , mayachta , sikta , utji , utjisuti , sutinaka , apsusuti Listas \u00b6 push , ch'ullu , apsu , apsuuka , utjit , chaninaka , chanim Matem\u00e1tica \u00b6 sin , cos , tan , asin , acos , atan , sqrt , pow , exp , log , log10 , floor , ceil , round , fabs flowchart LR Builtins[Funciones integradas] --> IO[Entrada/Salida] Builtins --> Texto Builtins --> Listas Builtins --> Matematica Builtins --> Arrays Siguiente: Manejo de errores","title":"Referencia r\u00e1pida"},{"location":"aymaraLang/#referencia-rapida-del-lenguaje","text":"Esta p\u00e1gina resume lo esencial del lenguaje para consulta r\u00e1pida. Para la gram\u00e1tica formal revisa Gram\u00e1tica .","title":"Referencia r\u00e1pida del lenguaje"},{"location":"aymaraLang/#tipos","text":"jakh\u00fcwi (num\u00e9rico) aru (texto) chiqa (booleano) t'aqa / lista\u00f1a (listas) mapa (mapas)","title":"Tipos"},{"location":"aymaraLang/#literales","text":"Booleanos: chiqa / k'ari (legacy: utji / janiutji ). N\u00fameros: decimales, 0x (hex) y 0b (binario). Cadenas: comillas simples o dobles con escapes.","title":"Literales"},{"location":"aymaraLang/#estructuras-principales","text":"Condicionales: jisa / maysatxa Bucles: ukhakamaxa , taki Funciones: lurawi / kuttaya Clases: kasta , machaqa , aka , jila , jikxata , sapa , taqi , sapakasta , u\u00f1t'aya , chura , jilaaka Excepciones: yant'a\u00f1a , katja\u00f1a , tukuyawi , pantja M\u00f3dulos: apnaq","title":"Estructuras principales"},{"location":"aymaraLang/#biblioteca-estandar-built-ins","text":"","title":"Biblioteca est\u00e1ndar (built-ins)"},{"location":"aymaraLang/#entradasalida-y-utilidades","text":"qillqa , write , input , katu , sleep , random","title":"Entrada/Salida y utilidades"},{"location":"aymaraLang/#conversion-y-longitud","text":"aru , jakh\u00fcwi , length , largo , suyu , suyut , suyum","title":"Conversi\u00f3n y longitud"},{"location":"aymaraLang/#arreglos-dinamicos","text":"array , array_get , array_set , array_free , array_length","title":"Arreglos (din\u00e1micos)"},{"location":"aymaraLang/#texto","text":"ch'usa , jaljta , mayachta , sikta , utji , utjisuti , sutinaka , apsusuti","title":"Texto"},{"location":"aymaraLang/#listas","text":"push , ch'ullu , apsu , apsuuka , utjit , chaninaka , chanim","title":"Listas"},{"location":"aymaraLang/#matematica","text":"sin , cos , tan , asin , acos , atan , sqrt , pow , exp , log , log10 , floor , ceil , round , fabs flowchart LR Builtins[Funciones integradas] --> IO[Entrada/Salida] Builtins --> Texto Builtins --> Listas Builtins --> Matematica Builtins --> Arrays Siguiente: Manejo de errores","title":"Matem\u00e1tica"},{"location":"build/","text":"Compilaci\u00f3n e instalaci\u00f3n (gu\u00eda unificada) \u00b6 Esta gu\u00eda consolida los pasos de compilaci\u00f3n, empaquetado e instalaci\u00f3n para AymaraLang. Requisitos \u00b6 CMake >= 3.15 Compilador C++17 ( g++ , clang++ o MSVC) NASM GCC/LD (Linux) o MinGW (Windows) Build r\u00e1pido con CMake (recomendado) \u00b6 Linux/macOS \u00b6 cmake -S . -B build -DCMAKE_BUILD_TYPE = Release cmake --build build -j Windows (MinGW) \u00b6 cmake -S . -B build -G \"MinGW Makefiles\" -DCMAKE_BUILD_TYPE = Release cmake - -build build -j El binario queda en build/bin/aymc (o build/bin/aymc.exe ). Flujo de build (resumen) \u00b6 flowchart LR A[Fuente C++/CMake] --> B[Generaci\u00f3n build/] B --> C[Compilaci\u00f3n] C --> D[Enlace] D --> E[aymc] Scripts de dependencias \u00b6 Linux: scripts/install_deps_linux.sh (apt/dnf/pacman). Windows: scripts/install_deps_windows.ps1 (winget/choco/scoop). Empaquetado y distribuciones \u00b6 Windows (dist + instaladores) \u00b6 ./ scripts / build_dist . ps1 -Config Release ./ scripts / build_msi . ps1 ./ scripts / build_nsis . ps1 Los instaladores quedan en artifacts/ . Linux ( .deb ) \u00b6 cmake -S . -B build -DCMAKE_BUILD_TYPE = Release cmake --build build -j cmake --install build --prefix dist bash scripts/build_deb.sh Notas \u00b6 El runtime debe acompa\u00f1ar a aymc para compilar programas (carpeta runtime/ ). Alternativas legacy: make (Linux) y build.bat (Windows). Siguiente: CLI del compilador","title":"Compilaci\u00f3n e instalaci\u00f3n"},{"location":"build/#compilacion-e-instalacion-guia-unificada","text":"Esta gu\u00eda consolida los pasos de compilaci\u00f3n, empaquetado e instalaci\u00f3n para AymaraLang.","title":"Compilaci\u00f3n e instalaci\u00f3n (gu\u00eda unificada)"},{"location":"build/#requisitos","text":"CMake >= 3.15 Compilador C++17 ( g++ , clang++ o MSVC) NASM GCC/LD (Linux) o MinGW (Windows)","title":"Requisitos"},{"location":"build/#build-rapido-con-cmake-recomendado","text":"","title":"Build r\u00e1pido con CMake (recomendado)"},{"location":"build/#linuxmacos","text":"cmake -S . -B build -DCMAKE_BUILD_TYPE = Release cmake --build build -j","title":"Linux/macOS"},{"location":"build/#windows-mingw","text":"cmake -S . -B build -G \"MinGW Makefiles\" -DCMAKE_BUILD_TYPE = Release cmake - -build build -j El binario queda en build/bin/aymc (o build/bin/aymc.exe ).","title":"Windows (MinGW)"},{"location":"build/#flujo-de-build-resumen","text":"flowchart LR A[Fuente C++/CMake] --> B[Generaci\u00f3n build/] B --> C[Compilaci\u00f3n] C --> D[Enlace] D --> E[aymc]","title":"Flujo de build (resumen)"},{"location":"build/#scripts-de-dependencias","text":"Linux: scripts/install_deps_linux.sh (apt/dnf/pacman). Windows: scripts/install_deps_windows.ps1 (winget/choco/scoop).","title":"Scripts de dependencias"},{"location":"build/#empaquetado-y-distribuciones","text":"","title":"Empaquetado y distribuciones"},{"location":"build/#windows-dist-instaladores","text":"./ scripts / build_dist . ps1 -Config Release ./ scripts / build_msi . ps1 ./ scripts / build_nsis . ps1 Los instaladores quedan en artifacts/ .","title":"Windows (dist + instaladores)"},{"location":"build/#linux-deb","text":"cmake -S . -B build -DCMAKE_BUILD_TYPE = Release cmake --build build -j cmake --install build --prefix dist bash scripts/build_deb.sh","title":"Linux (.deb)"},{"location":"build/#notas","text":"El runtime debe acompa\u00f1ar a aymc para compilar programas (carpeta runtime/ ). Alternativas legacy: make (Linux) y build.bat (Windows). Siguiente: CLI del compilador","title":"Notas"},{"location":"compiler/","text":"CLI del compilador \u00b6 aymc compila archivos .aym a ejecutables nativos. Por defecto genera el binario junto al archivo de entrada. Uso b\u00e1sico \u00b6 aymc archivo.aym Si se entregan varios archivos, se concatenan en una sola unidad de compilaci\u00f3n. sequenceDiagram participant U as Usuario participant C as aymc participant FS as Sistema de archivos U->>C: aymc archivo.aym C->>FS: leer fuente C->>C: lexer/parser/sem\u00e1ntica C->>FS: escribir asm/obj/binario C-->>U: ejecutable listo Opciones principales \u00b6 -o <ruta> : nombre/salida del ejecutable. --debug : imprime tokens en consola. --dump-ast : imprime el total de nodos del AST. --windows / --linux : fuerza plataforma de salida. --seed <valor> : fija la semilla del generador pseudoaleatorio. --llvm : genera output.ll (requiere compilar con soporte LLVM). Archivos generados \u00b6 output.asm : c\u00f3digo NASM (temporal, seg\u00fan plataforma). output.o / output.obj : objeto intermedio. output / output.exe : ejecutable final. Resoluci\u00f3n de m\u00f3dulos \u00b6 La sentencia apnaq(\"ruta\") busca m\u00f3dulos en: El directorio del archivo principal. Una carpeta modules/ dentro de ese directorio. Rutas adicionales definidas en la variable de entorno AYM_PATH . Siguiente: Arquitectura del compilador","title":"CLI del compilador"},{"location":"compiler/#cli-del-compilador","text":"aymc compila archivos .aym a ejecutables nativos. Por defecto genera el binario junto al archivo de entrada.","title":"CLI del compilador"},{"location":"compiler/#uso-basico","text":"aymc archivo.aym Si se entregan varios archivos, se concatenan en una sola unidad de compilaci\u00f3n. sequenceDiagram participant U as Usuario participant C as aymc participant FS as Sistema de archivos U->>C: aymc archivo.aym C->>FS: leer fuente C->>C: lexer/parser/sem\u00e1ntica C->>FS: escribir asm/obj/binario C-->>U: ejecutable listo","title":"Uso b\u00e1sico"},{"location":"compiler/#opciones-principales","text":"-o <ruta> : nombre/salida del ejecutable. --debug : imprime tokens en consola. --dump-ast : imprime el total de nodos del AST. --windows / --linux : fuerza plataforma de salida. --seed <valor> : fija la semilla del generador pseudoaleatorio. --llvm : genera output.ll (requiere compilar con soporte LLVM).","title":"Opciones principales"},{"location":"compiler/#archivos-generados","text":"output.asm : c\u00f3digo NASM (temporal, seg\u00fan plataforma). output.o / output.obj : objeto intermedio. output / output.exe : ejecutable final.","title":"Archivos generados"},{"location":"compiler/#resolucion-de-modulos","text":"La sentencia apnaq(\"ruta\") busca m\u00f3dulos en: El directorio del archivo principal. Una carpeta modules/ dentro de ese directorio. Rutas adicionales definidas en la variable de entorno AYM_PATH . Siguiente: Arquitectura del compilador","title":"Resoluci\u00f3n de m\u00f3dulos"},{"location":"exceptions/","text":"Manejo de errores \u00b6 AymaraLang soporta try/catch/finally con palabras clave en aymara. Sintaxis base \u00b6 yant'a\u00f1a { // c\u00f3digo que puede fallar } katja\u00f1a(e) { // manejo de error } tukuyawi { // se ejecuta siempre } stateDiagram-v2 [*] --> Try Try --> Catch: pantja Try --> Finally: fin normal Catch --> Finally Finally --> [*] Lanzar excepciones \u00b6 pantja(\"TIPO\", \"mensaje\"); Ejemplo m\u00ednimo \u00b6 yant'a\u00f1a { pantja(\"CONVERSION\", \"dato inv\u00e1lido\"); } katja\u00f1a(\"CONVERSION\", e) { qillqa(e.suti); qillqa(e.aru); } Siguiente: Gram\u00e1tica formal","title":"Manejo de errores"},{"location":"exceptions/#manejo-de-errores","text":"AymaraLang soporta try/catch/finally con palabras clave en aymara.","title":"Manejo de errores"},{"location":"exceptions/#sintaxis-base","text":"yant'a\u00f1a { // c\u00f3digo que puede fallar } katja\u00f1a(e) { // manejo de error } tukuyawi { // se ejecuta siempre } stateDiagram-v2 [*] --> Try Try --> Catch: pantja Try --> Finally: fin normal Catch --> Finally Finally --> [*]","title":"Sintaxis base"},{"location":"exceptions/#lanzar-excepciones","text":"pantja(\"TIPO\", \"mensaje\");","title":"Lanzar excepciones"},{"location":"exceptions/#ejemplo-minimo","text":"yant'a\u00f1a { pantja(\"CONVERSION\", \"dato inv\u00e1lido\"); } katja\u00f1a(\"CONVERSION\", e) { qillqa(e.suti); qillqa(e.aru); } Siguiente: Gram\u00e1tica formal","title":"Ejemplo m\u00ednimo"},{"location":"grammar/","text":"Gram\u00e1tica de AymaraLang (AruQillqa) \u00b6 Este documento describe la gram\u00e1tica actual del lenguaje AymaraLang utilizando notaci\u00f3n EBNF y resume los tokens reconocidos por el compilador. Las reglas de tokenizaci\u00f3n est\u00e1n implementadas en compiler/lexer/lexer.cpp . Tokens l\u00e9xicos \u00b6 flowchart LR A[Texto .aym] --> B[Lexer] B --> C[Tokens] C --> D[Parser] D --> E[AST] Palabras clave \u00b6 Token Lexema(s) aceptado(s) Uso sint\u00e1ctico KeywordStart qallta Inicio del programa KeywordEnd tukuya Fin del programa KeywordDeclare yatiya Declaraci\u00f3n de variables KeywordPrint qillqa Sentencia de impresi\u00f3n KeywordIf suti , jisa Condicional KeywordElse jani , maysatxa Rama alternativa KeywordWhile kunawsati , ukhakamaxa Bucle while KeywordFor sap\u00fcru , taki Bucle for KeywordBreak p'akhi\u00f1a Salir de un bucle KeywordContinue saranta\u00f1a Continuar bucle KeywordFunc lurawi Definici\u00f3n de funciones KeywordReturn kuttaya Retorno KeywordImport apnaq Importaci\u00f3n KeywordTry yant'a\u00f1a Bloque try KeywordCatch katja\u00f1a Bloque catch KeywordFinally tukuyawi Bloque finally KeywordThrow pantja Lanzar excepci\u00f3n KeywordClass kasta Definici\u00f3n de clases KeywordNew machaqa Crear instancia KeywordThis aka Referencia al objeto actual KeywordExtends jila Herencia KeywordOverride jikxata Sobrescribir m\u00e9todo KeywordPrivate sapa Modificador privado KeywordPublic taqi Modificador p\u00fablico KeywordStatic sapakasta Modificador est\u00e1tico KeywordGetter u\u00f1t'aya Nombre reservado para getter KeywordSetter chura Nombre reservado para setter KeywordSuper jilaaka Referencia al padre KeywordTypeNumber jakh\u00fcwi Tipo num\u00e9rico KeywordTypeString aru Tipo cadena KeywordTypeBool chiqa Tipo booleano KeywordTypeList lista\u00f1a , t'aqa Tipo lista KeywordTypeMap mapa Tipo mapa (Espa\u00f1ol) KeywordTrue utji , chiqa Literal verdadero KeywordFalse janiutji , k'ari Literal falso Operadores y delimitadores \u00b6 Los s\u00edmbolos se mantienen sin cambios: Agrupaci\u00f3n: () , {} , [] Fin de sentencia: ; Separador: , Asignaci\u00f3n: = Dos puntos: : Operadores: + - * / % ^ Comparaci\u00f3n: == != < <= > >= L\u00f3gicos: && || ! Comentarios: // y /* */ Literales \u00b6 Number : n\u00fameros enteros decimales con soporte 0x y 0b . String : cadenas entre comillas dobles o simples con escapes ( \\n , \\t , \\\" , \\' , etc.). Notaci\u00f3n EBNF utilizada \u00b6 a* indica repetici\u00f3n de cero o m\u00e1s veces. a+ indica una o m\u00e1s repeticiones. [a] marca un elemento opcional. a | b representa alternativas. Gram\u00e1tica sint\u00e1ctica \u00b6 programa = [ \"qallta\" ] { sentencia } [ \"tukuya\" ] ; sentencia = decl | asigna | if | while | for | func_def | class_def | retorno | salida | continuar | imprimir | importar | try | throw | bloque | \";\" ; bloque = \"{\" { sentencia } \"}\" ; decl = \"yatiya\" tipo id [ \"=\" expr ] \";\" ; tipo = \"jakh\u00fcwi\" | \"aru\" | \"chiqa\" | \"lista\u00f1a\" | \"t'aqa\" | \"mapa\" | id ; asigna = id \"=\" expr \";\" ; if = ( \"suti\" | \"jisa\" ) \"(\" cond \")\" bloque [ ( \"jani\" | \"maysatxa\" ) bloque ] ; while = ( \"kunawsati\" | \"ukhakamaxa\" ) \"(\" cond \")\" bloque ; for = ( \"sap\u00fcru\" | \"taki\" ) \"(\" [ decl | asigna ] \";\" [ cond ] \";\" [ asigna_np ] \")\" bloque ; asigna_np = id \"=\" expr ; func_def = \"lurawi\" id \"(\" [ params ] \")\" [ \":\" tipo ] bloque ; params = param { \",\" param } ; param = tipo id ; class_def = \"kasta\" id [ \"jila\" id ] \"{\" { class_member } \"}\" ; class_member = { modificador } ( decl | metodo | ctor ) ; modificador = \"sapa\" | \"taqi\" | \"sapakasta\" | \"jikxata\" ; metodo = \"lurawi\" id \"(\" [ params ] \")\" [ \":\" tipo ] bloque ; ctor = \"qallta\" \"(\" [ params ] \")\" bloque ; retorno = \"kuttaya\" [ expr ] \";\" ; salida = \"p'akhi\u00f1a\" \";\" ; continuar = \"saranta\u00f1a\" \";\" ; throw = \"pantja\" \"(\" ( str | id ) [ \",\" str ] \")\" \";\" ; try = \"yant'a\u00f1a\" bloque { catch } [ finally ] ; catch = \"katja\u00f1a\" \"(\" [ str \",\" ] id \")\" bloque ; finally = \"tukuyawi\" bloque ; imprimir = \"qillqa\" \"(\" [ args ] \")\" \";\" ; importar = \"apnaq\" \"(\" str \")\" \";\" ; args = expr { \",\" expr } ; cond = expr ; expr = or ; or = and { \"||\" and } ; and = igualdad { \"&&\" igualdad } ; igualdad = rel { ( \"==\" | \"!=\" ) rel } ; rel = suma { ( \"<\" | \"<=\" | \">\" | \">=\" ) suma } ; suma = multi { ( \"+\" | \"-\" ) multi } ; multi = unario { ( \"*\" | \"/\" | \"%\" ) unario } ; unario = [ \"!\" | \"-\" ] primario ; primario = num | str | ( \"utji\" | \"chiqa\" ) | ( \"janiutji\" | \"k'ari\" ) | \"machaqa\" id \"(\" [ args ] \")\" | \"aka\" | \"jilaaka\" | id | llamada | \"(\" expr \")\" | lista ; llamada = id \"(\" [ args ] \")\" ; lista = \"[\" [ args ] \"]\" ; id = letra { letra | num | \"_\" } ; num = digito { digito } ; str = '\\\"' { caracter } '\\\"' | \\ \"'\\\" { caracter } \\ \"'\\\" ; Anterior: Referencia del lenguaje | Siguiente: Arquitectura del compilador","title":"Gram\u00e1tica formal"},{"location":"grammar/#gramatica-de-aymaralang-aruqillqa","text":"Este documento describe la gram\u00e1tica actual del lenguaje AymaraLang utilizando notaci\u00f3n EBNF y resume los tokens reconocidos por el compilador. Las reglas de tokenizaci\u00f3n est\u00e1n implementadas en compiler/lexer/lexer.cpp .","title":"Gram\u00e1tica de AymaraLang (AruQillqa)"},{"location":"grammar/#tokens-lexicos","text":"flowchart LR A[Texto .aym] --> B[Lexer] B --> C[Tokens] C --> D[Parser] D --> E[AST]","title":"Tokens l\u00e9xicos"},{"location":"grammar/#palabras-clave","text":"Token Lexema(s) aceptado(s) Uso sint\u00e1ctico KeywordStart qallta Inicio del programa KeywordEnd tukuya Fin del programa KeywordDeclare yatiya Declaraci\u00f3n de variables KeywordPrint qillqa Sentencia de impresi\u00f3n KeywordIf suti , jisa Condicional KeywordElse jani , maysatxa Rama alternativa KeywordWhile kunawsati , ukhakamaxa Bucle while KeywordFor sap\u00fcru , taki Bucle for KeywordBreak p'akhi\u00f1a Salir de un bucle KeywordContinue saranta\u00f1a Continuar bucle KeywordFunc lurawi Definici\u00f3n de funciones KeywordReturn kuttaya Retorno KeywordImport apnaq Importaci\u00f3n KeywordTry yant'a\u00f1a Bloque try KeywordCatch katja\u00f1a Bloque catch KeywordFinally tukuyawi Bloque finally KeywordThrow pantja Lanzar excepci\u00f3n KeywordClass kasta Definici\u00f3n de clases KeywordNew machaqa Crear instancia KeywordThis aka Referencia al objeto actual KeywordExtends jila Herencia KeywordOverride jikxata Sobrescribir m\u00e9todo KeywordPrivate sapa Modificador privado KeywordPublic taqi Modificador p\u00fablico KeywordStatic sapakasta Modificador est\u00e1tico KeywordGetter u\u00f1t'aya Nombre reservado para getter KeywordSetter chura Nombre reservado para setter KeywordSuper jilaaka Referencia al padre KeywordTypeNumber jakh\u00fcwi Tipo num\u00e9rico KeywordTypeString aru Tipo cadena KeywordTypeBool chiqa Tipo booleano KeywordTypeList lista\u00f1a , t'aqa Tipo lista KeywordTypeMap mapa Tipo mapa (Espa\u00f1ol) KeywordTrue utji , chiqa Literal verdadero KeywordFalse janiutji , k'ari Literal falso","title":"Palabras clave"},{"location":"grammar/#operadores-y-delimitadores","text":"Los s\u00edmbolos se mantienen sin cambios: Agrupaci\u00f3n: () , {} , [] Fin de sentencia: ; Separador: , Asignaci\u00f3n: = Dos puntos: : Operadores: + - * / % ^ Comparaci\u00f3n: == != < <= > >= L\u00f3gicos: && || ! Comentarios: // y /* */","title":"Operadores y delimitadores"},{"location":"grammar/#literales","text":"Number : n\u00fameros enteros decimales con soporte 0x y 0b . String : cadenas entre comillas dobles o simples con escapes ( \\n , \\t , \\\" , \\' , etc.).","title":"Literales"},{"location":"grammar/#notacion-ebnf-utilizada","text":"a* indica repetici\u00f3n de cero o m\u00e1s veces. a+ indica una o m\u00e1s repeticiones. [a] marca un elemento opcional. a | b representa alternativas.","title":"Notaci\u00f3n EBNF utilizada"},{"location":"grammar/#gramatica-sintactica","text":"programa = [ \"qallta\" ] { sentencia } [ \"tukuya\" ] ; sentencia = decl | asigna | if | while | for | func_def | class_def | retorno | salida | continuar | imprimir | importar | try | throw | bloque | \";\" ; bloque = \"{\" { sentencia } \"}\" ; decl = \"yatiya\" tipo id [ \"=\" expr ] \";\" ; tipo = \"jakh\u00fcwi\" | \"aru\" | \"chiqa\" | \"lista\u00f1a\" | \"t'aqa\" | \"mapa\" | id ; asigna = id \"=\" expr \";\" ; if = ( \"suti\" | \"jisa\" ) \"(\" cond \")\" bloque [ ( \"jani\" | \"maysatxa\" ) bloque ] ; while = ( \"kunawsati\" | \"ukhakamaxa\" ) \"(\" cond \")\" bloque ; for = ( \"sap\u00fcru\" | \"taki\" ) \"(\" [ decl | asigna ] \";\" [ cond ] \";\" [ asigna_np ] \")\" bloque ; asigna_np = id \"=\" expr ; func_def = \"lurawi\" id \"(\" [ params ] \")\" [ \":\" tipo ] bloque ; params = param { \",\" param } ; param = tipo id ; class_def = \"kasta\" id [ \"jila\" id ] \"{\" { class_member } \"}\" ; class_member = { modificador } ( decl | metodo | ctor ) ; modificador = \"sapa\" | \"taqi\" | \"sapakasta\" | \"jikxata\" ; metodo = \"lurawi\" id \"(\" [ params ] \")\" [ \":\" tipo ] bloque ; ctor = \"qallta\" \"(\" [ params ] \")\" bloque ; retorno = \"kuttaya\" [ expr ] \";\" ; salida = \"p'akhi\u00f1a\" \";\" ; continuar = \"saranta\u00f1a\" \";\" ; throw = \"pantja\" \"(\" ( str | id ) [ \",\" str ] \")\" \";\" ; try = \"yant'a\u00f1a\" bloque { catch } [ finally ] ; catch = \"katja\u00f1a\" \"(\" [ str \",\" ] id \")\" bloque ; finally = \"tukuyawi\" bloque ; imprimir = \"qillqa\" \"(\" [ args ] \")\" \";\" ; importar = \"apnaq\" \"(\" str \")\" \";\" ; args = expr { \",\" expr } ; cond = expr ; expr = or ; or = and { \"||\" and } ; and = igualdad { \"&&\" igualdad } ; igualdad = rel { ( \"==\" | \"!=\" ) rel } ; rel = suma { ( \"<\" | \"<=\" | \">\" | \">=\" ) suma } ; suma = multi { ( \"+\" | \"-\" ) multi } ; multi = unario { ( \"*\" | \"/\" | \"%\" ) unario } ; unario = [ \"!\" | \"-\" ] primario ; primario = num | str | ( \"utji\" | \"chiqa\" ) | ( \"janiutji\" | \"k'ari\" ) | \"machaqa\" id \"(\" [ args ] \")\" | \"aka\" | \"jilaaka\" | id | llamada | \"(\" expr \")\" | lista ; llamada = id \"(\" [ args ] \")\" ; lista = \"[\" [ args ] \"]\" ; id = letra { letra | num | \"_\" } ; num = digito { digito } ; str = '\\\"' { caracter } '\\\"' | \\ \"'\\\" { caracter } \\ \"'\\\" ; Anterior: Referencia del lenguaje | Siguiente: Arquitectura del compilador","title":"Gram\u00e1tica sint\u00e1ctica"},{"location":"investigacion/","text":"Investigaci\u00f3n y teor\u00eda \u00b6 Esta secci\u00f3n resume fundamentos matem\u00e1ticos y de compiladores que sustentan el proyecto y su documentaci\u00f3n de ingenier\u00eda. Matem\u00e1tica discreta \u00b6 Conjuntos y relaciones \u00b6 Un lenguaje formal puede definirse como un conjunto de cadenas: \\[L \\subseteq \\Sigma^*\\] donde \\(\\Sigma\\) es el alfabeto y \\(\\Sigma^*\\) el conjunto de todas las cadenas. flowchart LR Sigma[\u03a3] --> SigmaStar[\u03a3*] SigmaStar --> Language[L] Grafos \u00b6 Un grafo dirigido se representa como \\(G = (V, E)\\) con \\(E \\subseteq V \\times V\\) . Esto es \u00fatil para describir grafos de flujo de control y dependencias. graph TD S[Inicio] --> A[Lexing] A --> B[Parsing] B --> C[Sem\u00e1ntica] C --> D[Codegen] Teor\u00eda de compiladores \u00b6 Fases cl\u00e1sicas \u00b6 flowchart LR Fuente --> Lexer --> Parser --> AST --> Semantica --> Codegen --> Binario Gram\u00e1ticas y lenguajes \u00b6 Una gram\u00e1tica libre de contexto se define como: \\[G = (N, \\Sigma, P, S)\\] \\(N\\) : no terminales \\(\\Sigma\\) : terminales \\(P\\) : producciones \\(S\\) : s\u00edmbolo inicial Complejidad \u00b6 Para un parser LL sin retroceso, el costo total suele ser lineal en el n\u00famero de tokens \\(n\\) : \\[T(n) = O(n)\\] Matem\u00e1tica aplicada al runtime \u00b6 La generaci\u00f3n de n\u00fameros pseudoaleatorios utiliza una semilla \\(s\\) que permite reproducibilidad. Si se define \\(x_{k+1} = f(x_k)\\) , el estado del generador es una sucesi\u00f3n determinista dada la semilla inicial. Aplicaci\u00f3n La opci\u00f3n --seed fija \\(s\\) para reproducir resultados en pruebas. Compiladores y verificaci\u00f3n \u00b6 sequenceDiagram participant Req as Requisitos participant V as Verificaci\u00f3n participant C as C\u00f3digo Req->>V: define criterios V->>C: ejecuta pruebas C-->>V: evidencia V-->>Req: cumplimiento","title":"Fundamentos"},{"location":"investigacion/#investigacion-y-teoria","text":"Esta secci\u00f3n resume fundamentos matem\u00e1ticos y de compiladores que sustentan el proyecto y su documentaci\u00f3n de ingenier\u00eda.","title":"Investigaci\u00f3n y teor\u00eda"},{"location":"investigacion/#matematica-discreta","text":"","title":"Matem\u00e1tica discreta"},{"location":"investigacion/#conjuntos-y-relaciones","text":"Un lenguaje formal puede definirse como un conjunto de cadenas: \\[L \\subseteq \\Sigma^*\\] donde \\(\\Sigma\\) es el alfabeto y \\(\\Sigma^*\\) el conjunto de todas las cadenas. flowchart LR Sigma[\u03a3] --> SigmaStar[\u03a3*] SigmaStar --> Language[L]","title":"Conjuntos y relaciones"},{"location":"investigacion/#grafos","text":"Un grafo dirigido se representa como \\(G = (V, E)\\) con \\(E \\subseteq V \\times V\\) . Esto es \u00fatil para describir grafos de flujo de control y dependencias. graph TD S[Inicio] --> A[Lexing] A --> B[Parsing] B --> C[Sem\u00e1ntica] C --> D[Codegen]","title":"Grafos"},{"location":"investigacion/#teoria-de-compiladores","text":"","title":"Teor\u00eda de compiladores"},{"location":"investigacion/#fases-clasicas","text":"flowchart LR Fuente --> Lexer --> Parser --> AST --> Semantica --> Codegen --> Binario","title":"Fases cl\u00e1sicas"},{"location":"investigacion/#gramaticas-y-lenguajes","text":"Una gram\u00e1tica libre de contexto se define como: \\[G = (N, \\Sigma, P, S)\\] \\(N\\) : no terminales \\(\\Sigma\\) : terminales \\(P\\) : producciones \\(S\\) : s\u00edmbolo inicial","title":"Gram\u00e1ticas y lenguajes"},{"location":"investigacion/#complejidad","text":"Para un parser LL sin retroceso, el costo total suele ser lineal en el n\u00famero de tokens \\(n\\) : \\[T(n) = O(n)\\]","title":"Complejidad"},{"location":"investigacion/#matematica-aplicada-al-runtime","text":"La generaci\u00f3n de n\u00fameros pseudoaleatorios utiliza una semilla \\(s\\) que permite reproducibilidad. Si se define \\(x_{k+1} = f(x_k)\\) , el estado del generador es una sucesi\u00f3n determinista dada la semilla inicial. Aplicaci\u00f3n La opci\u00f3n --seed fija \\(s\\) para reproducir resultados en pruebas.","title":"Matem\u00e1tica aplicada al runtime"},{"location":"investigacion/#compiladores-y-verificacion","text":"sequenceDiagram participant Req as Requisitos participant V as Verificaci\u00f3n participant C as C\u00f3digo Req->>V: define criterios V->>C: ejecuta pruebas C-->>V: evidencia V-->>Req: cumplimiento","title":"Compiladores y verificaci\u00f3n"},{"location":"language/","text":"Primeros pasos con AymaraLang \u00b6 Ejemplos m\u00ednimos para escribir tus primeros programas. Hola mundo \u00b6 qillqa(\"Kamisaraki!\"); Tipos y variables \u00b6 yatiya jakh\u00fcwi contador = 3; yatiya aru saludo = \"kamisaraki\"; yatiya chiqa activo = chiqa; mindmap root((AymaraLang)) Tipos jakh\u00fcwi aru chiqa t'aqa Control jisa/maysatxa ukhakamaxa taki Funciones lurawi kuttaya M\u00f3dulos apnaq Control de flujo \u00b6 jisa (contador > 0) { qillqa(saludo); } maysatxa { qillqa(\"janiwa\"); } ukhakamaxa (contador > 0) { contador--; } taki (yatiya jakh\u00fcwi i = 0; i < 3; i++) { qillqa(i); } Funciones \u00b6 lurawi inc(jakh\u00fcwi n) : jakh\u00fcwi { kuttaya n + 1; } qillqa(inc(5)); Notas matem\u00e1ticas r\u00e1pidas \u00b6 La longitud de una lista \\(L\\) se expresa como \\(|L|\\) y se obtiene con largo o suyut . M\u00f3dulos \u00b6 apnaq(\"modules/aritmetica\"); qillqa(\"suma: \" + suma(3, 4)); Comentarios \u00b6 // comentario de l\u00ednea /* comentario de bloque */ Palabras clave legacy \u00b6 Se mantiene compatibilidad con las formas suti / jani , kunawsati , sap\u00fcru y utji / janiutji . Siguiente: Referencia r\u00e1pida","title":"Primeros pasos"},{"location":"language/#primeros-pasos-con-aymaralang","text":"Ejemplos m\u00ednimos para escribir tus primeros programas.","title":"Primeros pasos con AymaraLang"},{"location":"language/#hola-mundo","text":"qillqa(\"Kamisaraki!\");","title":"Hola mundo"},{"location":"language/#tipos-y-variables","text":"yatiya jakh\u00fcwi contador = 3; yatiya aru saludo = \"kamisaraki\"; yatiya chiqa activo = chiqa; mindmap root((AymaraLang)) Tipos jakh\u00fcwi aru chiqa t'aqa Control jisa/maysatxa ukhakamaxa taki Funciones lurawi kuttaya M\u00f3dulos apnaq","title":"Tipos y variables"},{"location":"language/#control-de-flujo","text":"jisa (contador > 0) { qillqa(saludo); } maysatxa { qillqa(\"janiwa\"); } ukhakamaxa (contador > 0) { contador--; } taki (yatiya jakh\u00fcwi i = 0; i < 3; i++) { qillqa(i); }","title":"Control de flujo"},{"location":"language/#funciones","text":"lurawi inc(jakh\u00fcwi n) : jakh\u00fcwi { kuttaya n + 1; } qillqa(inc(5));","title":"Funciones"},{"location":"language/#notas-matematicas-rapidas","text":"La longitud de una lista \\(L\\) se expresa como \\(|L|\\) y se obtiene con largo o suyut .","title":"Notas matem\u00e1ticas r\u00e1pidas"},{"location":"language/#modulos","text":"apnaq(\"modules/aritmetica\"); qillqa(\"suma: \" + suma(3, 4));","title":"M\u00f3dulos"},{"location":"language/#comentarios","text":"// comentario de l\u00ednea /* comentario de bloque */","title":"Comentarios"},{"location":"language/#palabras-clave-legacy","text":"Se mantiene compatibilidad con las formas suti / jani , kunawsati , sap\u00fcru y utji / janiutji . Siguiente: Referencia r\u00e1pida","title":"Palabras clave legacy"},{"location":"overview/","text":"Visi\u00f3n general \u00b6 AymaraLang ( .aym ) es un lenguaje de programaci\u00f3n con sintaxis en aymara y un compilador ( aymc ) implementado en C++17 . El compilador genera ejecutables nativos (con extensi\u00f3n .exe en Windows). El runtime acompa\u00f1a al binario para resolver funciones est\u00e1ndar. Identidad y alcance actual \u00b6 Elemento Detalle Compilador aymc Lenguaje AymaraLang ( .aym ) Salida Binario nativo (sin extensi\u00f3n en Unix, .exe en Windows) Paradigma Imperativo con soporte de funciones y clases Tipado Est\u00e1tico, fuerte Backend principal NASM + enlazado por GCC/LD (o MinGW) Backend opcional LLVM (si se compila con soporte) Principios del proyecto \u00b6 Cercan\u00eda cultural: palabras clave en aymara y ejemplos contextualizados. Compilaci\u00f3n nativa: no requiere VM para ejecutar los binarios generados. Modularidad: el compilador separa lexer, parser, sem\u00e1ntica y codegen. Documentaci\u00f3n de investigaci\u00f3n: incluye ingenier\u00eda de sistemas y LaTeX. Sintaxis base \u00b6 Bloques con {} y fin de sentencia con ; . Palabras clave en aymara ( jisa , taki , lurawi , etc.). Comentarios // y /* */ . Contexto del sistema \u00b6 flowchart LR A[Usuario] -->|Escribe c\u00f3digo .aym| B[Editor o CLI] B --> C[Compilador aymc] C --> D[Ejecutable nativo] D --> E[Runtime del lenguaje] La salida nativa evita una m\u00e1quina virtual, y el costo dominante se concentra en las fases de an\u00e1lisis. En t\u00e9rminos simplificados, si \\(n\\) es el n\u00famero de tokens, el parseo LL se mantiene en \\(O(n)\\) . Siguiente: Primeros pasos","title":"Visi\u00f3n general"},{"location":"overview/#vision-general","text":"AymaraLang ( .aym ) es un lenguaje de programaci\u00f3n con sintaxis en aymara y un compilador ( aymc ) implementado en C++17 . El compilador genera ejecutables nativos (con extensi\u00f3n .exe en Windows). El runtime acompa\u00f1a al binario para resolver funciones est\u00e1ndar.","title":"Visi\u00f3n general"},{"location":"overview/#identidad-y-alcance-actual","text":"Elemento Detalle Compilador aymc Lenguaje AymaraLang ( .aym ) Salida Binario nativo (sin extensi\u00f3n en Unix, .exe en Windows) Paradigma Imperativo con soporte de funciones y clases Tipado Est\u00e1tico, fuerte Backend principal NASM + enlazado por GCC/LD (o MinGW) Backend opcional LLVM (si se compila con soporte)","title":"Identidad y alcance actual"},{"location":"overview/#principios-del-proyecto","text":"Cercan\u00eda cultural: palabras clave en aymara y ejemplos contextualizados. Compilaci\u00f3n nativa: no requiere VM para ejecutar los binarios generados. Modularidad: el compilador separa lexer, parser, sem\u00e1ntica y codegen. Documentaci\u00f3n de investigaci\u00f3n: incluye ingenier\u00eda de sistemas y LaTeX.","title":"Principios del proyecto"},{"location":"overview/#sintaxis-base","text":"Bloques con {} y fin de sentencia con ; . Palabras clave en aymara ( jisa , taki , lurawi , etc.). Comentarios // y /* */ .","title":"Sintaxis base"},{"location":"overview/#contexto-del-sistema","text":"flowchart LR A[Usuario] -->|Escribe c\u00f3digo .aym| B[Editor o CLI] B --> C[Compilador aymc] C --> D[Ejecutable nativo] D --> E[Runtime del lenguaje] La salida nativa evita una m\u00e1quina virtual, y el costo dominante se concentra en las fases de an\u00e1lisis. En t\u00e9rminos simplificados, si \\(n\\) es el n\u00famero de tokens, el parseo LL se mantiene en \\(O(n)\\) . Siguiente: Primeros pasos","title":"Contexto del sistema"},{"location":"project/","text":"Gu\u00eda del proyecto \u00b6 Tecnolog\u00edas y herramientas \u00b6 Lenguaje: C++17 Assembler: NASM Enlace: GCC/LD (Linux) o MinGW (Windows) Build: CMake (principal), make / build.bat (legacy) Extensi\u00f3n de VS Code: aymlang/ Tests: carpeta tests/ Extensi\u00f3n para Visual Studio Code \u00b6 La extensi\u00f3n vive en aymlang/ y ofrece resaltado y snippets. Para empaquetar un .vsix : cd aymlang npm install npx @vscode/vsce package Luego instala el .vsix desde VS Code ( Extensions \u2192 Install from VSIX ). Documentaci\u00f3n y materiales de investigaci\u00f3n \u00b6 Sitio MkDocs en docs/ . Ingenier\u00eda de sistemas en docs/systems_engineering/ . Fuentes LaTeX/Overleaf en docs/systems_engineering/overleaf/ . Estructura del repositorio (resumen) \u00b6 compiler/ # compilador C++ runtime/ # runtime est\u00e1ndar aymlang/ # extensi\u00f3n VS Code scripts/ # automatizaciones de build/packaging samples/ # ejemplos .aym tests/ # pruebas automatizadas flowchart LR Compiler[compiler/] --> Runtime[runtime/] Compiler --> Scripts[scripts/] Compiler --> Samples[samples/] Compiler --> Tests[tests/] Compiler --> VSCode[aymlang/]","title":"Gu\u00eda del proyecto"},{"location":"project/#guia-del-proyecto","text":"","title":"Gu\u00eda del proyecto"},{"location":"project/#tecnologias-y-herramientas","text":"Lenguaje: C++17 Assembler: NASM Enlace: GCC/LD (Linux) o MinGW (Windows) Build: CMake (principal), make / build.bat (legacy) Extensi\u00f3n de VS Code: aymlang/ Tests: carpeta tests/","title":"Tecnolog\u00edas y herramientas"},{"location":"project/#extension-para-visual-studio-code","text":"La extensi\u00f3n vive en aymlang/ y ofrece resaltado y snippets. Para empaquetar un .vsix : cd aymlang npm install npx @vscode/vsce package Luego instala el .vsix desde VS Code ( Extensions \u2192 Install from VSIX ).","title":"Extensi\u00f3n para Visual Studio Code"},{"location":"project/#documentacion-y-materiales-de-investigacion","text":"Sitio MkDocs en docs/ . Ingenier\u00eda de sistemas en docs/systems_engineering/ . Fuentes LaTeX/Overleaf en docs/systems_engineering/overleaf/ .","title":"Documentaci\u00f3n y materiales de investigaci\u00f3n"},{"location":"project/#estructura-del-repositorio-resumen","text":"compiler/ # compilador C++ runtime/ # runtime est\u00e1ndar aymlang/ # extensi\u00f3n VS Code scripts/ # automatizaciones de build/packaging samples/ # ejemplos .aym tests/ # pruebas automatizadas flowchart LR Compiler[compiler/] --> Runtime[runtime/] Compiler --> Scripts[scripts/] Compiler --> Samples[samples/] Compiler --> Tests[tests/] Compiler --> VSCode[aymlang/]","title":"Estructura del repositorio (resumen)"},{"location":"systems_engineering/architecture/","text":"Descripci\u00f3n de Arquitectura del Sistema \u00b6 1. Visi\u00f3n general \u00b6 AymaraLang est\u00e1 compuesto por un compilador modular ( aymc ), un runtime m\u00ednimo y herramientas de apoyo. La arquitectura sigue el flujo cl\u00e1sico de compiladores con m\u00f3dulos desacoplados. 2. Arquitectura funcional \u00b6 flowchart LR A[Fuente .aym] --> B[Lexer] B --> C[Parser] C --> D[AST] D --> E[Sem\u00e1ntica] E --> F[Codegen NASM] F --> G[Linker] E --> H[LLVM opcional] H --> I[IR .ll] M\u00f3dulo Responsabilidad Entradas Salidas Lexer Tokenizaci\u00f3n de c\u00f3digo fuente .aym Tokens Parser Construcci\u00f3n de AST Tokens AST Semantic An\u00e1lisis sem\u00e1ntico y tipos AST AST validado + s\u00edmbolos Codegen Generaci\u00f3n de NASM/LLVM AST validado .asm / .ll Linker Ensamblado/enlace .asm Binario 3. Arquitectura f\u00edsica (deployment) \u00b6 Entorno local: Linux/Windows. Dependencias: NASM, GCC/LD o MinGW, compilador C++17. Artefactos: .asm , .ll , binario nativo, logs de error. 4. Interfaces clave \u00b6 CLI: aymc [opciones] archivo.aym . Sistema de archivos: lectura de fuentes, escritura de artefactos. Runtime: funciones b\u00e1sicas de E/S utilizadas por el ejecutable. 5. Datos e informaci\u00f3n \u00b6 Tokens: tipo, texto, l\u00ednea y columna. AST: nodos de expresiones y sentencias. S\u00edmbolos: tablas de alcance para variables y funciones. 6. Restricciones de dise\u00f1o \u00b6 C++17 como est\u00e1ndar base. Codegen x86_64 (NASM) como backend principal. LLVM como backend opcional.","title":"Arquitectura de Sistemas"},{"location":"systems_engineering/architecture/#descripcion-de-arquitectura-del-sistema","text":"","title":"Descripci\u00f3n de Arquitectura del Sistema"},{"location":"systems_engineering/architecture/#1-vision-general","text":"AymaraLang est\u00e1 compuesto por un compilador modular ( aymc ), un runtime m\u00ednimo y herramientas de apoyo. La arquitectura sigue el flujo cl\u00e1sico de compiladores con m\u00f3dulos desacoplados.","title":"1. Visi\u00f3n general"},{"location":"systems_engineering/architecture/#2-arquitectura-funcional","text":"flowchart LR A[Fuente .aym] --> B[Lexer] B --> C[Parser] C --> D[AST] D --> E[Sem\u00e1ntica] E --> F[Codegen NASM] F --> G[Linker] E --> H[LLVM opcional] H --> I[IR .ll] M\u00f3dulo Responsabilidad Entradas Salidas Lexer Tokenizaci\u00f3n de c\u00f3digo fuente .aym Tokens Parser Construcci\u00f3n de AST Tokens AST Semantic An\u00e1lisis sem\u00e1ntico y tipos AST AST validado + s\u00edmbolos Codegen Generaci\u00f3n de NASM/LLVM AST validado .asm / .ll Linker Ensamblado/enlace .asm Binario","title":"2. Arquitectura funcional"},{"location":"systems_engineering/architecture/#3-arquitectura-fisica-deployment","text":"Entorno local: Linux/Windows. Dependencias: NASM, GCC/LD o MinGW, compilador C++17. Artefactos: .asm , .ll , binario nativo, logs de error.","title":"3. Arquitectura f\u00edsica (deployment)"},{"location":"systems_engineering/architecture/#4-interfaces-clave","text":"CLI: aymc [opciones] archivo.aym . Sistema de archivos: lectura de fuentes, escritura de artefactos. Runtime: funciones b\u00e1sicas de E/S utilizadas por el ejecutable.","title":"4. Interfaces clave"},{"location":"systems_engineering/architecture/#5-datos-e-informacion","text":"Tokens: tipo, texto, l\u00ednea y columna. AST: nodos de expresiones y sentencias. S\u00edmbolos: tablas de alcance para variables y funciones.","title":"5. Datos e informaci\u00f3n"},{"location":"systems_engineering/architecture/#6-restricciones-de-diseno","text":"C++17 como est\u00e1ndar base. Codegen x86_64 (NASM) como backend principal. LLVM como backend opcional.","title":"6. Restricciones de dise\u00f1o"},{"location":"systems_engineering/conops/","text":"Concepto de Operaciones (ConOps) \u00b6 1. Prop\u00f3sito \u00b6 Describir c\u00f3mo los usuarios interact\u00faan con AymaraLang y su compilador aymc en escenarios reales, incluyendo flujos operativos, roles y restricciones. 2. Escenarios operativos \u00b6 2.1 Uso educativo en aula \u00b6 Docente distribuye ejemplos .aym . Estudiantes editan el c\u00f3digo en un editor de texto. Ejecutan aymc para compilar y correr los binarios. Se analiza salida para reforzar conceptos de programaci\u00f3n. sequenceDiagram participant D as Docente participant E as Estudiante participant C as aymc D->>E: entrega ejercicios .aym E->>C: compila programa C-->>E: binario ejecutable E-->>D: resultados/retroalimentaci\u00f3n 2.2 Uso comunitario y cultural \u00b6 Creaci\u00f3n de materiales educativos en aymara. Publicaci\u00f3n de ejemplos y ejercicios. Ejecuci\u00f3n en equipos modestos sin depender de conexi\u00f3n a internet. 3. Actores y responsabilidades \u00b6 Actor Responsabilidad Usuario final Escribir y ejecutar programas .aym Docente Dise\u00f1ar ejercicios y guiar el aprendizaje Desarrollador del compilador Mantener el compilador y documentaci\u00f3n 4. Supuestos \u00b6 El entorno cuenta con compilador C++ y herramientas de ensamblado/enlace. El usuario dispone de acceso de lectura/escritura al sistema de archivos. 5. Limitaciones operativas \u00b6 El backend LLVM es opcional y puede no estar disponible. Soporte limitado a x86_64 en la generaci\u00f3n nativa. 6. Criterios de \u00e9xito operacional \u00b6 Compilaci\u00f3n exitosa en menos de 2 segundos para ejemplos educativos. Ejecuci\u00f3n consistente en Windows y Linux. Mensajes de error comprensibles para estudiantes.","title":"CONOPS"},{"location":"systems_engineering/conops/#concepto-de-operaciones-conops","text":"","title":"Concepto de Operaciones (ConOps)"},{"location":"systems_engineering/conops/#1-proposito","text":"Describir c\u00f3mo los usuarios interact\u00faan con AymaraLang y su compilador aymc en escenarios reales, incluyendo flujos operativos, roles y restricciones.","title":"1. Prop\u00f3sito"},{"location":"systems_engineering/conops/#2-escenarios-operativos","text":"","title":"2. Escenarios operativos"},{"location":"systems_engineering/conops/#21-uso-educativo-en-aula","text":"Docente distribuye ejemplos .aym . Estudiantes editan el c\u00f3digo en un editor de texto. Ejecutan aymc para compilar y correr los binarios. Se analiza salida para reforzar conceptos de programaci\u00f3n. sequenceDiagram participant D as Docente participant E as Estudiante participant C as aymc D->>E: entrega ejercicios .aym E->>C: compila programa C-->>E: binario ejecutable E-->>D: resultados/retroalimentaci\u00f3n","title":"2.1 Uso educativo en aula"},{"location":"systems_engineering/conops/#22-uso-comunitario-y-cultural","text":"Creaci\u00f3n de materiales educativos en aymara. Publicaci\u00f3n de ejemplos y ejercicios. Ejecuci\u00f3n en equipos modestos sin depender de conexi\u00f3n a internet.","title":"2.2 Uso comunitario y cultural"},{"location":"systems_engineering/conops/#3-actores-y-responsabilidades","text":"Actor Responsabilidad Usuario final Escribir y ejecutar programas .aym Docente Dise\u00f1ar ejercicios y guiar el aprendizaje Desarrollador del compilador Mantener el compilador y documentaci\u00f3n","title":"3. Actores y responsabilidades"},{"location":"systems_engineering/conops/#4-supuestos","text":"El entorno cuenta con compilador C++ y herramientas de ensamblado/enlace. El usuario dispone de acceso de lectura/escritura al sistema de archivos.","title":"4. Supuestos"},{"location":"systems_engineering/conops/#5-limitaciones-operativas","text":"El backend LLVM es opcional y puede no estar disponible. Soporte limitado a x86_64 en la generaci\u00f3n nativa.","title":"5. Limitaciones operativas"},{"location":"systems_engineering/conops/#6-criterios-de-exito-operacional","text":"Compilaci\u00f3n exitosa en menos de 2 segundos para ejemplos educativos. Ejecuci\u00f3n consistente en Windows y Linux. Mensajes de error comprensibles para estudiantes.","title":"6. Criterios de \u00e9xito operacional"},{"location":"systems_engineering/interface_control_document/","text":"Documento de Control de Interfaces (ICD) \u00b6 1. Prop\u00f3sito \u00b6 Definir las interfaces principales del sistema AymaraLang y sus contratos de uso. 2. Interfaces externas \u00b6 2.1 CLI del compilador \u00b6 Comando: aymc [opciones] archivo.aym ... Opciones principales: --debug , --dump-ast , --seed , --llvm , --windows , --linux , -o . flowchart LR User[Usuario] --> CLI[CLI aymc] CLI --> FS[Sistema de archivos] CLI --> Runtime[Runtime] CLI --> Backend[Backend NASM/LLVM] 2.2 Sistema de archivos \u00b6 Entradas: archivos .aym . Salidas: .asm , .ll y binario nativo. 2.3 Runtime \u00b6 Interfaz: llamadas a funciones integradas ( qillqa , katu , input , matem\u00e1ticas, arreglos, listas). 3. Interfaces internas \u00b6 Interfaz Descripci\u00f3n Lexer \u2192 Parser Tokens con tipo/lexema/posici\u00f3n Parser \u2192 Semantic AST de nodos Expr / Stmt Semantic \u2192 Codegen AST validado + s\u00edmbolos Codegen \u2192 Linker .asm o .ll 4. Reglas de interoperabilidad \u00b6 El parser debe consumir tokens bien formados del lexer. El codegen solo opera sobre AST validado. El runtime debe mantener compatibilidad con el ABI usado por codegen.","title":"Control de Interfaces (ICD)"},{"location":"systems_engineering/interface_control_document/#documento-de-control-de-interfaces-icd","text":"","title":"Documento de Control de Interfaces (ICD)"},{"location":"systems_engineering/interface_control_document/#1-proposito","text":"Definir las interfaces principales del sistema AymaraLang y sus contratos de uso.","title":"1. Prop\u00f3sito"},{"location":"systems_engineering/interface_control_document/#2-interfaces-externas","text":"","title":"2. Interfaces externas"},{"location":"systems_engineering/interface_control_document/#21-cli-del-compilador","text":"Comando: aymc [opciones] archivo.aym ... Opciones principales: --debug , --dump-ast , --seed , --llvm , --windows , --linux , -o . flowchart LR User[Usuario] --> CLI[CLI aymc] CLI --> FS[Sistema de archivos] CLI --> Runtime[Runtime] CLI --> Backend[Backend NASM/LLVM]","title":"2.1 CLI del compilador"},{"location":"systems_engineering/interface_control_document/#22-sistema-de-archivos","text":"Entradas: archivos .aym . Salidas: .asm , .ll y binario nativo.","title":"2.2 Sistema de archivos"},{"location":"systems_engineering/interface_control_document/#23-runtime","text":"Interfaz: llamadas a funciones integradas ( qillqa , katu , input , matem\u00e1ticas, arreglos, listas).","title":"2.3 Runtime"},{"location":"systems_engineering/interface_control_document/#3-interfaces-internas","text":"Interfaz Descripci\u00f3n Lexer \u2192 Parser Tokens con tipo/lexema/posici\u00f3n Parser \u2192 Semantic AST de nodos Expr / Stmt Semantic \u2192 Codegen AST validado + s\u00edmbolos Codegen \u2192 Linker .asm o .ll","title":"3. Interfaces internas"},{"location":"systems_engineering/interface_control_document/#4-reglas-de-interoperabilidad","text":"El parser debe consumir tokens bien formados del lexer. El codegen solo opera sobre AST validado. El runtime debe mantener compatibilidad con el ABI usado por codegen.","title":"4. Reglas de interoperabilidad"},{"location":"systems_engineering/requirements/","text":"Especificaci\u00f3n de requisitos y documentaci\u00f3n de ingenier\u00eda de sistemas (SEBOK/INCOSE) \u00b6 Basado en pr\u00e1cticas de SEBOK e INCOSE para captura de requisitos, definici\u00f3n de sistema y verificaci\u00f3n. 1. Prop\u00f3sito \u00b6 Definir los requisitos del sistema AymaraLang (aym) y su compilador aymc , as\u00ed como el contexto operativo, stakeholders, interfaces, restricciones y criterios de verificaci\u00f3n, utilizando una estructura compatible con SEBOK/INCOSE. 2. Alcance del sistema \u00b6 Sistema bajo estudio (SoS): - Compilador aymc (C++17) y backend de generaci\u00f3n de ejecutables. - Lenguaje AymaraLang (archivos fuente .aym ). - Runtime m\u00ednimo para E/S y utilidades est\u00e1ndar. Fuera de alcance: - IDEs o extensiones de editor. - Librer\u00edas est\u00e1ndar externas adicionales. - Integraci\u00f3n con servicios en la nube. 3. Stakeholders y necesidades \u00b6 Stakeholder Necesidad/objetivo Prioridad Docentes y estudiantes Lenguaje accesible y representativo del aymara Alta Desarrolladores del compilador Arquitectura modular y mantenible Alta Usuarios finales Ejecutables nativos r\u00e1pidos Alta Comunidad cultural Preservaci\u00f3n ling\u00fc\u00edstica y material educativo Media 4. Concepto de operaciones (ConOps) \u00b6 El usuario escribe c\u00f3digo .aym con sintaxis en aymara. Ejecuta aymc para compilar a un binario nativo ( .ayn o .exe ). El compilador realiza: lexer \u2192 parser \u2192 AST \u2192 an\u00e1lisis sem\u00e1ntico \u2192 codegen \u2192 ensamblado/enlace. El ejecutable resultante corre en el sistema objetivo. 5. Contexto del sistema y l\u00edmites \u00b6 Entorno operativo: - Sistemas Linux/Windows (con soporte de toolchain para NASM/LD/GCC o MinGW). - Dependencias de compilaci\u00f3n: g++ / clang++ , nasm , gcc/ld . Interfaces externas clave: - CLI del compilador ( aymc ). - Sistema de archivos (lectura .aym , escritura .asm / .ll y binarios). - Backend LLVM (opcional, activado con --llvm ). 6. Arquitectura funcional (resumen) \u00b6 Funci\u00f3n Entrada Salida An\u00e1lisis l\u00e9xico C\u00f3digo .aym Tokens An\u00e1lisis sint\u00e1ctico Tokens AST An\u00e1lisis sem\u00e1ntico AST AST validado + s\u00edmbolos Generaci\u00f3n de c\u00f3digo AST validado .asm / .ll Ensamblado/enlace .asm Binario nativo flowchart LR FR01[FR-01 CLI] --> Main[main.cpp] FR02[FR-02 Lexer] --> Lexer[compiler/lexer] FR03[FR-03 Parser] --> Parser[compiler/parser] FR04[FR-04 Sem\u00e1ntica] --> Semantic[compiler/semantic] FR05[FR-05 Codegen] --> Codegen[compiler/codegen] FR07[FR-07 LLVM] --> LLVM[compiler/codegen/llvm] 7. Requisitos del sistema \u00b6 7.1 Requisitos funcionales (FR) \u00b6 FR-01 El sistema debe aceptar uno o m\u00e1s archivos .aym como entrada por CLI. FR-02 El sistema debe tokenizar el c\u00f3digo fuente y producir tokens conforme a palabras clave y s\u00edmbolos del lenguaje. FR-03 El sistema debe generar un AST v\u00e1lido mediante an\u00e1lisis sint\u00e1ctico LL. FR-04 El sistema debe validar sem\u00e1ntica (tipado, s\u00edmbolos y llamadas) antes de generar c\u00f3digo. FR-05 El sistema debe generar ensamblador NASM x86_64 y enlazar un ejecutable nativo. FR-06 El sistema debe permitir seleccionar objetivo Linux o Windows desde la CLI. FR-07 El sistema debe admitir un backend LLVM experimental que genere .ll . FR-08 El sistema debe soportar m\u00f3dulos importados desde archivos externos. FR-09 El sistema debe incluir funciones integradas (E/S, matem\u00e1ticas, arreglos, aleatoriedad). 7.2 Requisitos no funcionales (NFR) \u00b6 NFR-01 El compilador debe ejecutarse en Linux y Windows con toolchain est\u00e1ndar. NFR-02 El tiempo de compilaci\u00f3n debe ser adecuado para programas educativos (<= 2s para archivos peque\u00f1os en equipos de clase). NFR-03 El sistema debe proporcionar mensajes de error legibles para errores l\u00e9xicos, sint\u00e1cticos y sem\u00e1nticos. NFR-04 El c\u00f3digo debe mantener una estructura modular (lexer/parser/ast/semantic/codegen). NFR-05 El proyecto debe compilarse con C++17. 7.3 Requisitos de interfaz (IR) \u00b6 IR-01 CLI principal: aymc [opciones] archivo.aym ... . IR-02 Opciones: --debug , --dump-ast , --seed , --llvm , --windows , --linux , -o . IR-03 Archivos de salida: .asm (NASM), .ll (LLVM), y ejecutable nativo. 8. Restricciones y supuestos \u00b6 Se requiere toolchain (NASM y GCC/LD o MinGW) disponible en PATH. El backend LLVM es opcional y depende de compilaci\u00f3n con soporte. El lenguaje est\u00e1 orientado a tipado est\u00e1tico y a constructs definidos en la gram\u00e1tica. 9. Verificaci\u00f3n y validaci\u00f3n (V&V) \u00b6 Requisito M\u00e9todo Evidencia esperada FR-01 Inspecci\u00f3n/Prueba aymc archivo.aym compila sin errores FR-05 Prueba Se genera .asm y binario ejecutable FR-07 Prueba Se genera archivo .ll NFR-05 Inspecci\u00f3n Uso de -std=c++17 en build 10. Trazabilidad (resumen) \u00b6 Requisito Elemento de dise\u00f1o Evidencia t\u00e9cnica FR-01 CLI main.cpp Parsing de argumentos FR-02 lexer/ Tokenizaci\u00f3n FR-03 parser/ Construcci\u00f3n de AST FR-04 semantic/ An\u00e1lisis de tipos FR-05 codegen/ Generaci\u00f3n NASM FR-07 codegen/llvm/ LLVM IR FR-08 module_resolver Resoluci\u00f3n de m\u00f3dulos FR-09 builtins/ Funciones integradas 11. Riesgos t\u00e9cnicos (alto nivel) \u00b6 Dependencia de toolchain externo para ensamblado/enlace. Backend LLVM incompleto o experimental. Compatibilidad limitada con arquitecturas distintas de x86_64. 12. Glosario \u00b6 AST: \u00c1rbol de Sintaxis Abstracta. V&V: Verificaci\u00f3n y validaci\u00f3n. ConOps: Concepto de operaciones.","title":"Requisitos"},{"location":"systems_engineering/requirements/#especificacion-de-requisitos-y-documentacion-de-ingenieria-de-sistemas-sebokincose","text":"Basado en pr\u00e1cticas de SEBOK e INCOSE para captura de requisitos, definici\u00f3n de sistema y verificaci\u00f3n.","title":"Especificaci\u00f3n de requisitos y documentaci\u00f3n de ingenier\u00eda de sistemas (SEBOK/INCOSE)"},{"location":"systems_engineering/requirements/#1-proposito","text":"Definir los requisitos del sistema AymaraLang (aym) y su compilador aymc , as\u00ed como el contexto operativo, stakeholders, interfaces, restricciones y criterios de verificaci\u00f3n, utilizando una estructura compatible con SEBOK/INCOSE.","title":"1. Prop\u00f3sito"},{"location":"systems_engineering/requirements/#2-alcance-del-sistema","text":"Sistema bajo estudio (SoS): - Compilador aymc (C++17) y backend de generaci\u00f3n de ejecutables. - Lenguaje AymaraLang (archivos fuente .aym ). - Runtime m\u00ednimo para E/S y utilidades est\u00e1ndar. Fuera de alcance: - IDEs o extensiones de editor. - Librer\u00edas est\u00e1ndar externas adicionales. - Integraci\u00f3n con servicios en la nube.","title":"2. Alcance del sistema"},{"location":"systems_engineering/requirements/#3-stakeholders-y-necesidades","text":"Stakeholder Necesidad/objetivo Prioridad Docentes y estudiantes Lenguaje accesible y representativo del aymara Alta Desarrolladores del compilador Arquitectura modular y mantenible Alta Usuarios finales Ejecutables nativos r\u00e1pidos Alta Comunidad cultural Preservaci\u00f3n ling\u00fc\u00edstica y material educativo Media","title":"3. Stakeholders y necesidades"},{"location":"systems_engineering/requirements/#4-concepto-de-operaciones-conops","text":"El usuario escribe c\u00f3digo .aym con sintaxis en aymara. Ejecuta aymc para compilar a un binario nativo ( .ayn o .exe ). El compilador realiza: lexer \u2192 parser \u2192 AST \u2192 an\u00e1lisis sem\u00e1ntico \u2192 codegen \u2192 ensamblado/enlace. El ejecutable resultante corre en el sistema objetivo.","title":"4. Concepto de operaciones (ConOps)"},{"location":"systems_engineering/requirements/#5-contexto-del-sistema-y-limites","text":"Entorno operativo: - Sistemas Linux/Windows (con soporte de toolchain para NASM/LD/GCC o MinGW). - Dependencias de compilaci\u00f3n: g++ / clang++ , nasm , gcc/ld . Interfaces externas clave: - CLI del compilador ( aymc ). - Sistema de archivos (lectura .aym , escritura .asm / .ll y binarios). - Backend LLVM (opcional, activado con --llvm ).","title":"5. Contexto del sistema y l\u00edmites"},{"location":"systems_engineering/requirements/#6-arquitectura-funcional-resumen","text":"Funci\u00f3n Entrada Salida An\u00e1lisis l\u00e9xico C\u00f3digo .aym Tokens An\u00e1lisis sint\u00e1ctico Tokens AST An\u00e1lisis sem\u00e1ntico AST AST validado + s\u00edmbolos Generaci\u00f3n de c\u00f3digo AST validado .asm / .ll Ensamblado/enlace .asm Binario nativo flowchart LR FR01[FR-01 CLI] --> Main[main.cpp] FR02[FR-02 Lexer] --> Lexer[compiler/lexer] FR03[FR-03 Parser] --> Parser[compiler/parser] FR04[FR-04 Sem\u00e1ntica] --> Semantic[compiler/semantic] FR05[FR-05 Codegen] --> Codegen[compiler/codegen] FR07[FR-07 LLVM] --> LLVM[compiler/codegen/llvm]","title":"6. Arquitectura funcional (resumen)"},{"location":"systems_engineering/requirements/#7-requisitos-del-sistema","text":"","title":"7. Requisitos del sistema"},{"location":"systems_engineering/requirements/#71-requisitos-funcionales-fr","text":"FR-01 El sistema debe aceptar uno o m\u00e1s archivos .aym como entrada por CLI. FR-02 El sistema debe tokenizar el c\u00f3digo fuente y producir tokens conforme a palabras clave y s\u00edmbolos del lenguaje. FR-03 El sistema debe generar un AST v\u00e1lido mediante an\u00e1lisis sint\u00e1ctico LL. FR-04 El sistema debe validar sem\u00e1ntica (tipado, s\u00edmbolos y llamadas) antes de generar c\u00f3digo. FR-05 El sistema debe generar ensamblador NASM x86_64 y enlazar un ejecutable nativo. FR-06 El sistema debe permitir seleccionar objetivo Linux o Windows desde la CLI. FR-07 El sistema debe admitir un backend LLVM experimental que genere .ll . FR-08 El sistema debe soportar m\u00f3dulos importados desde archivos externos. FR-09 El sistema debe incluir funciones integradas (E/S, matem\u00e1ticas, arreglos, aleatoriedad).","title":"7.1 Requisitos funcionales (FR)"},{"location":"systems_engineering/requirements/#72-requisitos-no-funcionales-nfr","text":"NFR-01 El compilador debe ejecutarse en Linux y Windows con toolchain est\u00e1ndar. NFR-02 El tiempo de compilaci\u00f3n debe ser adecuado para programas educativos (<= 2s para archivos peque\u00f1os en equipos de clase). NFR-03 El sistema debe proporcionar mensajes de error legibles para errores l\u00e9xicos, sint\u00e1cticos y sem\u00e1nticos. NFR-04 El c\u00f3digo debe mantener una estructura modular (lexer/parser/ast/semantic/codegen). NFR-05 El proyecto debe compilarse con C++17.","title":"7.2 Requisitos no funcionales (NFR)"},{"location":"systems_engineering/requirements/#73-requisitos-de-interfaz-ir","text":"IR-01 CLI principal: aymc [opciones] archivo.aym ... . IR-02 Opciones: --debug , --dump-ast , --seed , --llvm , --windows , --linux , -o . IR-03 Archivos de salida: .asm (NASM), .ll (LLVM), y ejecutable nativo.","title":"7.3 Requisitos de interfaz (IR)"},{"location":"systems_engineering/requirements/#8-restricciones-y-supuestos","text":"Se requiere toolchain (NASM y GCC/LD o MinGW) disponible en PATH. El backend LLVM es opcional y depende de compilaci\u00f3n con soporte. El lenguaje est\u00e1 orientado a tipado est\u00e1tico y a constructs definidos en la gram\u00e1tica.","title":"8. Restricciones y supuestos"},{"location":"systems_engineering/requirements/#9-verificacion-y-validacion-vv","text":"Requisito M\u00e9todo Evidencia esperada FR-01 Inspecci\u00f3n/Prueba aymc archivo.aym compila sin errores FR-05 Prueba Se genera .asm y binario ejecutable FR-07 Prueba Se genera archivo .ll NFR-05 Inspecci\u00f3n Uso de -std=c++17 en build","title":"9. Verificaci\u00f3n y validaci\u00f3n (V&amp;V)"},{"location":"systems_engineering/requirements/#10-trazabilidad-resumen","text":"Requisito Elemento de dise\u00f1o Evidencia t\u00e9cnica FR-01 CLI main.cpp Parsing de argumentos FR-02 lexer/ Tokenizaci\u00f3n FR-03 parser/ Construcci\u00f3n de AST FR-04 semantic/ An\u00e1lisis de tipos FR-05 codegen/ Generaci\u00f3n NASM FR-07 codegen/llvm/ LLVM IR FR-08 module_resolver Resoluci\u00f3n de m\u00f3dulos FR-09 builtins/ Funciones integradas","title":"10. Trazabilidad (resumen)"},{"location":"systems_engineering/requirements/#11-riesgos-tecnicos-alto-nivel","text":"Dependencia de toolchain externo para ensamblado/enlace. Backend LLVM incompleto o experimental. Compatibilidad limitada con arquitecturas distintas de x86_64.","title":"11. Riesgos t\u00e9cnicos (alto nivel)"},{"location":"systems_engineering/requirements/#12-glosario","text":"AST: \u00c1rbol de Sintaxis Abstracta. V&V: Verificaci\u00f3n y validaci\u00f3n. ConOps: Concepto de operaciones.","title":"12. Glosario"},{"location":"systems_engineering/risk_management/","text":"Plan de Gesti\u00f3n de Riesgos \u00b6 1. Objetivo \u00b6 Identificar, evaluar y mitigar riesgos t\u00e9cnicos y de proyecto asociados al desarrollo y uso de AymaraLang. 2. Metodolog\u00eda \u00b6 Identificaci\u00f3n de riesgos. Evaluaci\u00f3n de probabilidad e impacto. Planes de mitigaci\u00f3n y contingencia. flowchart LR A[Identificar] --> B[Evaluar] B --> C[Plan de mitigaci\u00f3n] C --> D[Monitorear] D --> A 3. Registro de riesgos \u00b6 ID Riesgo Probabilidad Impacto Mitigaci\u00f3n R-01 Dependencia de toolchain externo Media Alta Documentar dependencias y validar en CI R-02 Backend LLVM incompleto Media Media Mantener backend NASM como principal R-03 Compatibilidad limitada a x86_64 Alta Media Definir roadmap multi-arquitectura R-04 Curva de aprendizaje de sintaxis aymara Media Media Crear gu\u00edas y ejemplos accesibles R-05 Falta de recursos para pruebas en Windows Media Media Automatizar tests y usar runners multi-OS 4. Monitoreo \u00b6 Revisiones trimestrales del registro de riesgos. Seguimiento de issues en GitHub.","title":"Gesti\u00f3n de Riesgos"},{"location":"systems_engineering/risk_management/#plan-de-gestion-de-riesgos","text":"","title":"Plan de Gesti\u00f3n de Riesgos"},{"location":"systems_engineering/risk_management/#1-objetivo","text":"Identificar, evaluar y mitigar riesgos t\u00e9cnicos y de proyecto asociados al desarrollo y uso de AymaraLang.","title":"1. Objetivo"},{"location":"systems_engineering/risk_management/#2-metodologia","text":"Identificaci\u00f3n de riesgos. Evaluaci\u00f3n de probabilidad e impacto. Planes de mitigaci\u00f3n y contingencia. flowchart LR A[Identificar] --> B[Evaluar] B --> C[Plan de mitigaci\u00f3n] C --> D[Monitorear] D --> A","title":"2. Metodolog\u00eda"},{"location":"systems_engineering/risk_management/#3-registro-de-riesgos","text":"ID Riesgo Probabilidad Impacto Mitigaci\u00f3n R-01 Dependencia de toolchain externo Media Alta Documentar dependencias y validar en CI R-02 Backend LLVM incompleto Media Media Mantener backend NASM como principal R-03 Compatibilidad limitada a x86_64 Alta Media Definir roadmap multi-arquitectura R-04 Curva de aprendizaje de sintaxis aymara Media Media Crear gu\u00edas y ejemplos accesibles R-05 Falta de recursos para pruebas en Windows Media Media Automatizar tests y usar runners multi-OS","title":"3. Registro de riesgos"},{"location":"systems_engineering/risk_management/#4-monitoreo","text":"Revisiones trimestrales del registro de riesgos. Seguimiento de issues en GitHub.","title":"4. Monitoreo"},{"location":"systems_engineering/systems_engineering_management_plan/","text":"Plan de Gesti\u00f3n de Ingenier\u00eda de Sistemas (SEMP) \u00b6 1. Objetivo \u00b6 Establecer la estrategia, procesos y entregables de ingenier\u00eda de sistemas para AymaraLang. 2. Alcance \u00b6 Definici\u00f3n de requisitos (SRD). Arquitectura y dise\u00f1o. Verificaci\u00f3n y validaci\u00f3n. Gesti\u00f3n de configuraci\u00f3n y riesgos. 3. Procesos principales \u00b6 Proceso Actividades Requisitos Captura, an\u00e1lisis, trazabilidad Arquitectura Definici\u00f3n modular y interfaces Implementaci\u00f3n Desarrollo iterativo en C++17 V&V Pruebas, inspecciones, demostraciones Gesti\u00f3n de cambios Git + revisi\u00f3n por PR gantt title Plan de trabajo (alto nivel) dateFormat YYYY-MM-DD section Ingenier\u00eda Requisitos :done, reqs, 2024-01-01, 30d Arquitectura :done, arch, 2024-02-01, 30d Implementaci\u00f3n :active, impl, 2024-03-01, 60d Verificaci\u00f3n y V&V :vv, 2024-05-01, 30d 4. Entregables \u00b6 Especificaci\u00f3n de requisitos. ConOps. Documento de arquitectura. ICD. Plan de V&V. Registro de riesgos. 5. Gesti\u00f3n de configuraci\u00f3n \u00b6 Repositorio Git como fuente \u00fanica. Versionado sem\u00e1ntico para releases. Control de cambios v\u00eda PR. 6. M\u00e9tricas \u00b6 Porcentaje de requisitos verificados. Cobertura de pruebas en tests/ . Tiempo promedio de compilaci\u00f3n.","title":"Plan de Gesti\u00f3n (SEMP)"},{"location":"systems_engineering/systems_engineering_management_plan/#plan-de-gestion-de-ingenieria-de-sistemas-semp","text":"","title":"Plan de Gesti\u00f3n de Ingenier\u00eda de Sistemas (SEMP)"},{"location":"systems_engineering/systems_engineering_management_plan/#1-objetivo","text":"Establecer la estrategia, procesos y entregables de ingenier\u00eda de sistemas para AymaraLang.","title":"1. Objetivo"},{"location":"systems_engineering/systems_engineering_management_plan/#2-alcance","text":"Definici\u00f3n de requisitos (SRD). Arquitectura y dise\u00f1o. Verificaci\u00f3n y validaci\u00f3n. Gesti\u00f3n de configuraci\u00f3n y riesgos.","title":"2. Alcance"},{"location":"systems_engineering/systems_engineering_management_plan/#3-procesos-principales","text":"Proceso Actividades Requisitos Captura, an\u00e1lisis, trazabilidad Arquitectura Definici\u00f3n modular y interfaces Implementaci\u00f3n Desarrollo iterativo en C++17 V&V Pruebas, inspecciones, demostraciones Gesti\u00f3n de cambios Git + revisi\u00f3n por PR gantt title Plan de trabajo (alto nivel) dateFormat YYYY-MM-DD section Ingenier\u00eda Requisitos :done, reqs, 2024-01-01, 30d Arquitectura :done, arch, 2024-02-01, 30d Implementaci\u00f3n :active, impl, 2024-03-01, 60d Verificaci\u00f3n y V&V :vv, 2024-05-01, 30d","title":"3. Procesos principales"},{"location":"systems_engineering/systems_engineering_management_plan/#4-entregables","text":"Especificaci\u00f3n de requisitos. ConOps. Documento de arquitectura. ICD. Plan de V&V. Registro de riesgos.","title":"4. Entregables"},{"location":"systems_engineering/systems_engineering_management_plan/#5-gestion-de-configuracion","text":"Repositorio Git como fuente \u00fanica. Versionado sem\u00e1ntico para releases. Control de cambios v\u00eda PR.","title":"5. Gesti\u00f3n de configuraci\u00f3n"},{"location":"systems_engineering/systems_engineering_management_plan/#6-metricas","text":"Porcentaje de requisitos verificados. Cobertura de pruebas en tests/ . Tiempo promedio de compilaci\u00f3n.","title":"6. M\u00e9tricas"},{"location":"systems_engineering/verification_validation_plan/","text":"Plan de Verificaci\u00f3n y Validaci\u00f3n (V&V) \u00b6 1. Objetivo \u00b6 Definir c\u00f3mo se verificar\u00e1 y validar\u00e1 AymaraLang y su compilador para asegurar cumplimiento de requisitos. 2. Alcance \u00b6 Compilador aymc (lexer, parser, semantic, codegen). Backend LLVM experimental. Runtime m\u00ednimo. 3. Estrategia de V&V \u00b6 Tipo Descripci\u00f3n Inspecci\u00f3n Revisi\u00f3n de c\u00f3digo y documentaci\u00f3n Prueba Ejecuci\u00f3n de casos de prueba automatizados An\u00e1lisis Comparaci\u00f3n de resultados esperados flowchart LR A[Requisitos] --> B[Plan de pruebas] B --> C[Ejecuci\u00f3n] C --> D[Resultados] D --> E[Correcciones] E --> B 4. Matriz de verificaci\u00f3n (resumen) \u00b6 Requisito M\u00e9todo Evidencia FR-01 Prueba Compila m\u00faltiples archivos .aym FR-05 Prueba Binario ejecuta ejemplos FR-07 Prueba Generaci\u00f3n de .ll NFR-03 Inspecci\u00f3n Mensajes de error legibles 5. Criterios de aceptaci\u00f3n \u00b6 Todos los ejemplos en samples/ deben compilar y ejecutarse. make test debe pasar sin errores (cuando el entorno lo permita). 6. Artefactos de evidencia \u00b6 Reportes de ejecuci\u00f3n de make test . Logs de compilaci\u00f3n y salida de ejemplos.","title":"Verificaci\u00f3n y Validaci\u00f3n"},{"location":"systems_engineering/verification_validation_plan/#plan-de-verificacion-y-validacion-vv","text":"","title":"Plan de Verificaci\u00f3n y Validaci\u00f3n (V&amp;V)"},{"location":"systems_engineering/verification_validation_plan/#1-objetivo","text":"Definir c\u00f3mo se verificar\u00e1 y validar\u00e1 AymaraLang y su compilador para asegurar cumplimiento de requisitos.","title":"1. Objetivo"},{"location":"systems_engineering/verification_validation_plan/#2-alcance","text":"Compilador aymc (lexer, parser, semantic, codegen). Backend LLVM experimental. Runtime m\u00ednimo.","title":"2. Alcance"},{"location":"systems_engineering/verification_validation_plan/#3-estrategia-de-vv","text":"Tipo Descripci\u00f3n Inspecci\u00f3n Revisi\u00f3n de c\u00f3digo y documentaci\u00f3n Prueba Ejecuci\u00f3n de casos de prueba automatizados An\u00e1lisis Comparaci\u00f3n de resultados esperados flowchart LR A[Requisitos] --> B[Plan de pruebas] B --> C[Ejecuci\u00f3n] C --> D[Resultados] D --> E[Correcciones] E --> B","title":"3. Estrategia de V&amp;V"},{"location":"systems_engineering/verification_validation_plan/#4-matriz-de-verificacion-resumen","text":"Requisito M\u00e9todo Evidencia FR-01 Prueba Compila m\u00faltiples archivos .aym FR-05 Prueba Binario ejecuta ejemplos FR-07 Prueba Generaci\u00f3n de .ll NFR-03 Inspecci\u00f3n Mensajes de error legibles","title":"4. Matriz de verificaci\u00f3n (resumen)"},{"location":"systems_engineering/verification_validation_plan/#5-criterios-de-aceptacion","text":"Todos los ejemplos en samples/ deben compilar y ejecutarse. make test debe pasar sin errores (cuando el entorno lo permita).","title":"5. Criterios de aceptaci\u00f3n"},{"location":"systems_engineering/verification_validation_plan/#6-artefactos-de-evidencia","text":"Reportes de ejecuci\u00f3n de make test . Logs de compilaci\u00f3n y salida de ejemplos.","title":"6. Artefactos de evidencia"}]}